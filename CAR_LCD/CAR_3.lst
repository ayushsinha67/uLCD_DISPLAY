4DGL Compiler 2.6.0.5 -- Copyright 2004-2010 4D Labs
** D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\CAR_3.4DG compiled Sat Oct 20 02:55:18 2012

file D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\CAR_3.4DG

file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\uLCD-32PT_GFX2.fnc

0001  0001             #platform "uLCD-32PT_GFX2"
0002  0001             #platform "uLCD-32PT_GFX2"
0003  0008             */
0004  0009                 #constant ULCD_32PT_GFX
0005  0009                 #constant ULCD_32PT_GFX
0006  0010   
0007  0011                 #IFNOT EXISTS PICASO_GFX2_FUNCTIONS
file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\PicasoGFX2_Functions.fnc

0008  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0009  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0010  0001   
0011  0002             // Common inheritance for PicasoGFX2 platforms
0012  0003   
0013  0004             #constant PICASO_GFX_FUNCTIONS
0014  0004             #constant PICASO_GFX_FUNCTIONS
0015  0005   
0016  0006   
0017  0007             #CONST
0018  0017             #END
0019  0018   
0020  0019             #CONST
0021  0025             #END
0022  0026   
0023  0027   
0024  0028             #CONST
0025  0040             #END
0026  0041   
0027  0042   
0028  0043             #CONST
0029  0208             #END
0030  0209   
0031  0210   
0032  0211             // baud divisor rates for setbaud(n);
0033  0212             #CONST
0034  0234             #END
0035  0235   
0036  0236   
0037  0237   
0038  0238   
0039  0243             */
0040  0244   
0041  0245   
0042  0246             //==============================================//
0043  0247             // EVE bios functions                           //
0044  0248             //==============================================//
0045  0249                                                             //
0046  0250             func serin(), 1;                // read a byte from COM0
0047  0251             // Syntax: serin();
0048  0252             // Usage : char := serin();
0049  0253             // Notes : Receives a character from the Serial Port COM0. The transmission format is:
0050  0254             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0051  0255             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0052  0256             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0053  0257             //     : Returns: -1 if no character is available
0054  0258             //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
0055  0259             //     : Returns: positive value 0 to 255 for a valid character received
0056  0260   
0057  0261             func putch("char"), 0;                // write single char to current output device
0058  0262             // Syntax: putch("char");
0059  0263             // Usage : putch("A");
0060  0264             // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
0061  0265             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0062  0266             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0063  0267             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0064  0268             //     : The arguments can be a variable, array element, expression or constant
0065  0269   
0066  0270             func serout("char"), 0;                // write a byte to COM0
0067  0271             // Syntax: serout1("char");
0068  0272             // Usage : serout1(ch);
0069  0273             // Notes : send character to COM1
0070  0274   
0071  0275             func setbaud("baudnum"), 0;            // set baud rate of COM0
0072  0276             // Syntax: setbaud(baud_number);
0073  0277             // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
0074  0278             // *Notes : argument specifies the baud rate using pre-defined constant.
0075  0279             //       : The pre-defined constant is a value of 0-19 , and internally
0076  0280             //       : this is used as a table pointer to get the baud rate divisor
0077  0281             //       : value for one of the 20 selected baud rates, control is then
0078  0282             //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
0079  0283             //       : The pre-defined constants equate to a value of 0-19.
0080  0284             //       : If a value other than 0-19 is used, a run time error (eror 25)
0081  0285             //       : will occur.
0082  0286   
0083  0287             func to("device"), 1;                // output device redirection
0084  0288             // Syntax: to(outstream);
0085  0289             // Usage : to(APPEND); putstr("TWO ");
0086  0290             // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
0087  0291             //     :
0088  0292             //     : to() sends the printed output to destinations other than the screen. Normally, print just
0089  0293             //     : sends its output to the display in TEXT mode which is the default, however, the output from
0090  0294             //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
0091  0295             //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
0092  0296             //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
0093  0297             //     : completed its action. The APPEND argument is used to send the printed output to the same
0094  0298             //     : place as the previous redirection. This is most useful for building string arrays, or adding
0095  0299             //     : sequential data to a media stream.
0096  0300             //     :
0097  0301             //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
0098  0302             //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
0099  0303             //     :                            appended to user memory if previous redirection was to an array.
0100  0304             //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
0101  0305             //     : TEXT           0xFF08      Output is directed to the screen (default).
0102  0306             //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
0103  0307             //     : I2C            0xF820      Output is directed to the I2C port.
0104  0308             //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
0105  0309   
0106  0310   
0107  0311             func pause("milliseconds"), 0;            // blocking delay
0108  0312             // Syntax: pause(milliseconds);
0109  0313             // Usage : pause(1000);                //pause for 1 second
0110  0314             // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
0111  0315   
0112  0316             func putnum("arg1","arg2"), 1;            // print number to current output device
0113  0317             // Syntax: putnum(format, value);
0114  0318             // Usage : var := putnum(HEX, val);
0115  0319             // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
0116  0320             //     : Format: A constant that specifies the number format
0117  0321             //     : Value : The number to be printed
0118  0322             //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
0119  0323             //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
0120  0324             //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
0121  0325             //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
0122  0326             //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
0123  0327             //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
0124  0328             //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
0125  0329             //     :                                     BIN6     BIN6Z     BIN6ZB
0126  0330             //     :                                     BIN7     BIN7Z     BIN7ZB
0127  0331             //     :                                     BIN8     BIN8Z     BIN8ZB
0128  0332             //     :                                     BIN9     BIN9Z     BIN9ZB
0129  0333             //     :                                     BIN10     BIN10Z     BIN10ZB
0130  0334             //     :                                     BIN11     BIN11Z     BIN11ZB
0131  0335             //     :                                     BIN12     BIN12Z     BIN12ZB
0132  0336             //     :                                     BIN13     BIN13Z     BIN13ZB
0133  0337             //     :                                     BIN14     BIN14Z     BIN14ZB
0134  0338             //     :                                     BIN15     BIN15Z     BIN15ZB
0135  0339             //     :                                     BIN16     BIN16Z     BIN16ZB
0136  0340             //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
0137  0341             //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0138  0342             //     : | | | | \___ ___/ \__ __/ \_____ _____/
0139  0343             //     : | | | | V V V
0140  0344             //     : | | | | | | |
0141  0345             //     : | | | | | |
0142  0346             //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
0143  0347             //     : | | | | digit count |
0144  0348             //     : | | | | |___reserved (not used on GOLDELOX)
0145  0349             //     : | | | |
0146  0350             //     : | | | |
0147  0351             //     : | | | |
0148  0352             //     : | | | |
0149  0353             //     : | | | |
0150  0354             //     : | | | |______ 1 = leading zeros included
0151  0355             //     : | | | 0 = leading zeros suppressed
0152  0356             //     : | | |
0153  0357             //     : | | |
0154  0358             //     : | | |_______ 1 = leading zero blanking
0155  0359             //     : | |
0156  0360             //     : | |_____ sign bit (0 = signed, 1 = unsigned)
0157  0361             //     : |
0158  0362             //     : |______ 1 = space before unsigned number
0159  0363   
0160  0364   
0161  0365             func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
0162  0366   
0163  0367             func putstr("string"), 1;                       // print string to current output device
0164  0368             // Syntax: putstr(pointer);
0165  0369             // Usage : putstr("HELLO\n");
0166  0370             // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
0167  0371             //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
0168  0372             //       : a data statement. Note that string constants and data statement pointers are byte aligned.
0169  0373             //       : The output of putstr can be redirected to the communications port, the media, or memory
0170  0374             //       : using the to(...); function.
0171  0375             //       : A string constant is automatically terminated with a zero.
0172  0376             //       : A string in a data statement is not automatically terminated with a zero.
0173  0377             //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
0174  0378             //       : element packs 1 or 2 characters.
0175  0379   
0176  0380   
0177  0381             func strlen("varAddress"), 1;                   // return length of a var packed string in character units
0178  0382             // Syntax: strlen("varAddress);
0179  0383             // Usage : strlen("HELLO\n");
0180  0384             // Notes : gives the length of a string that is packed into regular var array
0181  0385             //       : Use str_Length(ptr)  for string pointer mode
0182  0386   
0183  0387   
0184  0388             //==============================================//
0185  0389             // Memory Access Function Prototypes            //
0186  0390             //==============================================//
0187  0391                                                             //
0188  0392             func peekW("address"), 1;                       // read a word from system memory
0189  0393             func pokeW("address", "wordvalue"), 0;          // write a word to system memory
0190  0394             // refer to address map of internal variables   //
0191  0395             //==============================================//
0192  0396             // Math Functions                               //
0193  0397             //==============================================//
0194  0398                                                             //
0195  0399             func ABS("value"), 1;                           // return a positive number
0196  0400             // Syntax: ABS(value);
0197  0401             // Usage : var := ABS(arg);
0198  0402             // Notes : Returns the absolute value of an argument
0199  0403   
0200  0404             func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
0201  0405             // Syntax: MIN(value1, value2);
0202  0406             // Usage : var := MIN(arg1, arg2);
0203  0407             // Notes : Returns the minimum of 2 arguments
0204  0408   
0205  0409             func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
0206  0410             // Syntax: MAX(value1, value2);
0207  0411             // Usage : var := MAX(arg1, arg2);
0208  0412             // Notes : Returns the maximum of 2 arguments
0209  0413   
0210  0414             func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
0211  0415             // Syntax: SWAP(&var1, &var2);
0212  0416             // Usage : SWAP(&var1, &var2);
0213  0417             // Notes : Swaps the contents of 2 variables or memory locations
0214  0418   
0215  0419             func SIN("angle"), 1;                           // return SIN of angle
0216  0420             // Syntax: SIN(angle);
0217  0421             // Usage : var := SIN(arg);
0218  0422             // Notes : Returns the sine in radians of an argument in degrees
0219  0423             //       : the returned value range is from 127 to -127. The real
0220  0424             //       : cosine values vary from 1.0 to -1.0 so appropriate
0221  0425             //       : scaling must be done in user code.
0222  0426   
0223  0427             func COS("angle"), 1;                           // return COS of angle
0224  0428             // Syntax: COS(angle);
0225  0429             // Usage : var := COS(arg);
0226  0430             // Notes : Returns the cosine in radians of an argument in degrees
0227  0431             //       : the returned value range is from 127 to -127. The real
0228  0432             //       : cosine values vary from 1.0 to -1.0 so appropriate
0229  0433             //       : scaling must be done in user code.
0230  0434   
0231  0435             func RAND(), 1;                                 // return a pseudo random number
0232  0436             // Syntax: RAND();
0233  0437             // Usage : var := RAND();
0234  0438             // Notes : Returns a random number between 0 and 0xFFFF.
0235  0439             //       : The random number generator must first be seeded
0236  0440             //       : by using the SEED(number) function.
0237  0441   
0238  0442             func SEED("number"), 0;                         // re-seed the pseudo random number generator
0239  0443             // Syntax: SEED(number);
0240  0444             // Usage : SEED(arg);
0241  0445             // Notes : Seeds the random number generator.
0242  0446   
0243  0447             func OVF(), 1;                                  // returns upper 16bits of 32bit results
0244  0448             // Syntax: OVF();
0245  0449             // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
0246  0450             //       : hiWord := OVF();
0247  0451             // Notes : This function returns the high order 16 bits from certain math and shift functions..
0248  0452   
0249  0453             func SQRT("number"), 1;                         // return square root of a number
0250  0454             // Syntax: SQRT(number);
0251  0455             // Usage : SQRT(arg);
0252  0456             // Notes : Returns the integer square root of a number.
0253  0457             //------------------------------------------------------------------//
0254  0458             //          Text Related Function Prototypes
0255  0459             //------------------------------------------------------------------//
0256  0460   
0257  0461             func txt_MoveCursor("line", "column"), 0;
0258  0462             // Syntax: txt_SetCursor(line, column);
0259  0463             // Usage : txt_SetCursor(arg1, arg2);
0260  0464             // Notes : Moves the text Cursor to a new screen position set by
0261  0465             //       : line,column parameters.
0262  0466   
0263  0467             func txt_Set("mode", "value"), 0;
0264  0468             // Syntax: txt_Set(mode, value);
0265  0469             // Usage : txt_Set(arg1, arg2);
0266  0470             // Returns : Original value before the change
0267  0471             // Notes : Sets various text related parameters used by other functions
0268  0472             //       : This allows the features to be set programatically with a
0269  0473             //       : single function call.It is strongly recommended to use the
0270  0474             //       : pre-defined constants rather than the mode numbers.
0271  0475             //       : NB:- Although it is often required to be able to set text
0272  0476             //       : functions with a single function call for graphics engine
0273  0477             //       : related functions, there is a complete set of single parameter
0274  0478             //       : shortcut functions that have exactly the same function as
0275  0479             //       : each of the txt_Set modes and saves 1 parameter / uses less memory
0276  0480             //       :
0277  0481             //       : mode = TEXT_COLOUR (mode 0)
0278  0482             //       : txt_Set(TEXT_COLOUR, value);
0279  0483             //       : value = 0 to 0xFFFF, Black to White
0280  0484             //       : Sets the Text colour for the display
0281  0485             //       : Default = LIME.
0282  0486             //       :
0283  0487             //       : mode = TEXT_HIGHLIGHT (mode 1)
0284  0488             //       : txt_Set(TEXT_HIGHLIGHT, value);
0285  0489             //       : value = 0 to 0xFFFF, Black to White
0286  0490             //       : Sets the Text background colour for the display. Effective
0287  0491             //       : when text mode is Opaque.
0288  0492             //       : Default = BLACK.
0289  0493             //       :
0290  0494             //       : mode = FONT_ID (mode 2)
0291  0495             //       : txt_Set(FONT_ID, value);
0292  0496             //       : value = FONT1, FONT2 or FONT3 for internal fonts
0293  0497             //       : else this value is the name of a font included
0294  0498             //       : in a users program in a data statement.
0295  0499             //       : Default = FONT SIZE 3.
0296  0500             //       :
0297  0501             //       : mode = TEXT_WIDTH  (mode 3)
0298  0502             //       : txt_Set(TEXT_WIDTH, value);
0299  0503             //       : value = 1 to 16
0300  0504             //       : Sets the Text Width multiplier
0301  0505             //       : text will be printed magnified horizontally
0302  0506             //       : by this factor, Default = 1.
0303  0507             //       :
0304  0508             //       : mode = TEXT_HEIGHT  (mode 4)
0305  0509             //       : txt_Set(TEXT_HEIGHT, value);
0306  0510             //       : value = 1 to 16
0307  0511             //       : Sets the Text Height multiplier
0308  0512             //       : text will be printed magnified vertically
0309  0513             //       : by this factor, Default = 1.
0310  0514             //       :
0311  0515             //       : mode = TEXT_XGAP  (mode 5)
0312  0516             //       : txt_Set(TEXT_XGAP, value);
0313  0517             //       : value = 1 to 32
0314  0518             //       : Sets the horizontal gap between characters
0315  0519             //       : The gap is in pixel units, Default = 0
0316  0520             //       :
0317  0521             //       : mode = TEXT_YGAP  (mode 6)
0318  0522             //       : txt_Set(TEXT_YGAP, value);
0319  0523             //       : value = 1 to 32
0320  0524             //       : Sets the vertical gap below characters
0321  0525             //       : The gap is in pixel units, Default = 0
0322  0526             //       :
0323  0527             //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
0324  0528             //       : txt_Set(TEXT_PRINTDELAY, value);
0325  0529             //       : value = 0 to 255
0326  0530             //       : Sets the delay time (in ms) during character
0327  0531             //       : printing to give a 'teletype' like effect.
0328  0532             //       : Often used to attract attention to a string
0329  0533             //       : being printed which can often be missed if
0330  0534             //       : just suddenly appearing or changing.
0331  0535             //       : Default = 0 ms.
0332  0536             //       :
0333  0537             //       : mode = TEXT_OPACITY (mode 8)
0334  0538             //       : txt_Set(TEXT_OPACITY, value);
0335  0539             //       : value = TRANSPARENT (0) = Text Trasparent
0336  0540             //       : value = OPAQUE (1) = Text Opaque
0337  0541             //       : Sets the Opacity/Transparency of the text
0338  0542             //       : Default = 0 or TRANSPARENT
0339  0543             //       :
0340  0544             //       : mode = TEXT_BOLD (mode 9)
0341  0545             //       : txt_Set(TEXT_BOLD, value);
0342  0546             //       : value = dont care
0343  0547             //       : Sets Bold Text mode for the next string or char
0344  0548             //       : The feature automatically resets after printing
0345  0549             //       : using putstr or print has completed
0346  0550             //       :
0347  0551             //       : mode = TEXT_ITALIC (mode 10)
0348  0552             //       : txt_Set(TEXT_ITALIC, value);
0349  0553             //       : value = dont care
0350  0554             //       : Sets Italic Text mode for the next string or char
0351  0555             //       : The feature automatically resets after printing
0352  0556             //       : using putstr or print has completed
0353  0557   
0354  0558             //       : mode = TEXT_INVERSE (mode 11)
0355  0559             //       : txt_Set(TEXT_INVERSE, value);
0356  0560             //       : value = dont care
0357  0561             //       : Sets Inverse Text mode for the next string or char
0358  0562             //       : The feature automatically resets after printing
0359  0563             //       : using putstr or print has completed
0360  0564             //       :
0361  0565             //       : mode = TEXT_UNDERLINED (mode 12)
0362  0566             //       : txt_Set(TEXT_UNDERLINED, value);
0363  0567             //       : value = dont care
0364  0568             //       : Sets Underlined Text mode for the next string or char
0365  0569             //       : The feature automatically resets after printing
0366  0570             //       : using putstr or print has completed
0367  0571             //       :
0368  0572             //       : mode = TEXT_ATTRIBUTES (mode 13)
0369  0573             //       : txt_Set(TEXT_ATTRIBUTES, value);
0370  0574             //       : value = bits are defined as:
0371  0575             //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
0372  0576             //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
0373  0577             //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
0374  0578             //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
0375  0579             //       : Allows a combination of text attributes to be defined together
0376  0580             //       : by 'or'ing the bits together.
0377  0581             //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
0378  0582             //       : The feature automatically resets after printing
0379  0583             //       : using putstr or print has completed.
0380  0584             //       : Bits 0-3 and 8-15 are reserved for future attributes.
0381  0585             //       :
0382  0586             //       : mode = TEXT_WRAP (mode 14)
0383  0587             //       : txt_Set(TEXT_WRAP , value);
0384  0588             //       : Sets the position where text wrap will occur
0385  0589             //       : The feature automatically resets when screen
0386  0590             //       : mode is changed. If the value is set to 0,
0387  0591             //       : text wrap is turned off.
0388  0592             //       : of the current screen. Default value is 0
0389  0593             // Notes : The value is in pixel units.
0390  0594             //       :
0391  0595   
0392  0596             //       : txt_Set mode 15 reserved for future use
0393  0597             //       :
0394  0598   
0395  0599   
0396  0600   
0397  0601             //=====================================================//
0398  0602             // Single parameter short-cuts                         //
0399  0603             // for the txt_Set functions                           //
0400  0604             // These functions return the existing value before    //
0401  0605             // the change is made.                                 //
0402  0606             //=====================================================//
0403  0607             func txt_FGcolour("colour"), 1;             // 0  text foreground colour
0404  0608             func txt_BGcolour("colour"), 1;             // 1  text background colour
0405  0609             func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
0406  0610             func txt_Width("multiplier"), 1;            // 3  text width multiplier
0407  0611             func txt_Height("multiplier"), 1;           // 4  text height multiplier
0408  0612             func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
0409  0613             func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
0410  0614             func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
0411  0615             func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
0412  0616             func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
0413  0617             func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
0414  0618             func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
0415  0619             func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
0416  0620             func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
0417  0621             func txt_Wrap("value"), 1;                  // 14 text set text wrap position
0418  0622             func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
0419  0623   
0420  0624   
0421  0625             //------------------------------------------------------------------//
0422  0626             //                 Hardware Function Prototypes
0423  0627             //------------------------------------------------------------------//
0424  0628   
0425  0629             // I/O Pin reference:-
0426  0630             //
0427  0631             //    IO1_PIN           is pin 2 of J1
0428  0632             //    IO2_PIN           is pin 1 of J1
0429  0633             //    IO3_PIN           is pin 3 of J1
0430  0634             //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
0431  0635             //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
0432  0636             //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
0433  0637             //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
0434  0638             //    BUS_0             is pin 27 of J1
0435  0639             //    BUS_1             is pin 25 of J1
0436  0640             //    BUS_2             is pin 23 of J1
0437  0641             //    BUS_3             is pin 21 of J1
0438  0642             //    BUS_4             is pin 19 of J1
0439  0643             //    BUS_5             is pin 17 of J1
0440  0644             //    BUS_6             is pin 13 of J2
0441  0645             //    BUS_7             is pin 11 of J2
0442  0646             //    BACKLITE          is backlite control pin
0443  0647             //    AUDIO_ENABLE      is amplifier chip control pin
0444  0648   
0445  0649             func pin_Set("mode", "pin"), 1;            // set pin to required mode
0446  0650             // Syntax: pin_Set(mode, pin);
0447  0651             // Usage : pin_Set(arg1, arg2);
0448  0652             // Notes : Sets the appropriate pins to Inputs or Outputs
0449  0653             //       : returns true if the pin number is legal (usually ignored)
0450  0654             //       :
0451  0655             //       : mode = 0 : Set Pin to Output
0452  0656             //       : pin_Set(0, pin);
0453  0657             //       : pin_Set(OUTPUT, pin);
0454  0658             //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
0455  0659             //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
0456  0660             //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
0457  0661             //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
0458  0662             //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
0459  0663             //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
0460  0664             //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
0461  0665             //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
0462  0666             //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
0463  0667             //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
0464  0668             //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
0465  0669             //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
0466  0670             //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
0467  0671             //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
0468  0672             //       : Sets the desired pin to be used as an Output.
0469  0673             //       :
0470  0674             //       : mode = 1 : Set Pin to Input
0471  0675             //       : pin_Set(1, pin);
0472  0676             //       : pin_Set(INPUT, pin);
0473  0677             //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
0474  0678             //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
0475  0679             //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
0476  0680             //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
0477  0681             //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
0478  0682             //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
0479  0683             //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
0480  0684             //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
0481  0685             //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
0482  0686             //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
0483  0687             //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
0484  0688             //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
0485  0689             //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
0486  0690             //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
0487  0691             //       : Sets the desired pin to be used as an Input.
0488  0692   
0489  0693             func pin_HI("pin"), 1;                    // set pin to logic '1'
0490  0694             // Syntax: pin_HI(pin);
0491  0695             // Usage : pin_HI(arg);
0492  0696             // Notes : Outputs a logic "High" (3.3V) on the appropriate
0493  0697             //       : pin that was previously selected as an Output.
0494  0698             //       : returns true if the pin number is legal (usually ignored)
0495  0699             //       :
0496  0700             //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
0497  0701             //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
0498  0702             //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
0499  0703             //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
0500  0704             //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
0501  0705             //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
0502  0706             //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
0503  0707             //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
0504  0708             //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
0505  0709             //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
0506  0710             //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
0507  0711             //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
0508  0712             //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
0509  0713             //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
0510  0714             //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
0511  0715   
0512  0716             func pin_LO("pin"), 1;                    // set pin to logic '0'
0513  0717             // Syntax: pin_LO(pin);
0514  0718             // Usage : pin_LO(arg);
0515  0719             // Notes : Outputs a logic "Low" (0V) on the appropriate
0516  0720             //       : pin that was previously selected as an Output.
0517  0721             //       : returns true if the pin number is legal (usually ignored)
0518  0722             //       :
0519  0723             //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
0520  0724             //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
0521  0725             //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
0522  0726             //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
0523  0727             //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
0524  0728             //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
0525  0729             //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
0526  0730             //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
0527  0731             //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
0528  0732             //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
0529  0733             //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
0530  0734             //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
0531  0735             //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
0532  0736             //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
0533  0737             //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
0534  0738   
0535  0739             func pin_Read("pin"), 1;                // read pin, logic or analogue
0536  0740             // Syntax: pin_Read(pin);
0537  0741             // Usage : arg1 := pin_Read(arg2);
0538  0742             // Notes : Reads the logic state of the appropriate
0539  0743             //       : pin that was previously selected as an Input.
0540  0744             //       :
0541  0745             //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
0542  0746             //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
0543  0747             //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
0544  0748             //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
0545  0749             //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
0546  0750             //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
0547  0751             //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
0548  0752             //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
0549  0753             //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
0550  0754             //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
0551  0755             //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
0552  0756             //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
0553  0757             //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
0554  0758             //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
0555  0759             //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
0556  0760             //       : Returns a 0 (logic low) or 1 (logic high).
0557  0761   
0558  0762   
0559  0763             //------------------------------------------------------------------//
0560  0764             //                 P1 module BUS I/O control
0561  0765             //------------------------------------------------------------------//
0562  0766   
0563  0767             func bus_In(), 1;
0564  0768             // Syntax: bus_In();
0565  0769             // Usage : arg1 := bus_In();
0566  0770             // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
0567  0771             //       : The upper 8 bits of arg1 are set to 0.
0568  0772             //       : the BUS_RD and BUS_WR pins are not affected.
0569  0773             //       :
0570  0774             //       : BUS_0 is pin 27 of J1
0571  0775             //       : BUS_1 is pin 25 of J1
0572  0776             //       : BUS_2 is pin 23 of J1
0573  0777             //       : BUS_3 is pin 21 of J1
0574  0778             //       : BUS_4 is pin 19 of J1
0575  0779             //       : BUS_5 is pin 17 of J1
0576  0780             //       : BUS_6 is pin 13 of J2
0577  0781             //       : BUS_7 is pin 11 of J2
0578  0782   
0579  0783             func bus_Out("var"), 0;
0580  0784             // Syntax: bus_Out(var);
0581  0785             // Usage : bus_Out(arg1);
0582  0786             // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
0583  0787             //       : The upper 8 bits of arg1 are ignored.
0584  0788             //       : the BUS_RD and BUS_WR pins are not affected.
0585  0789             //       : NB:- any BUS pins that are set to inputs are not affected.
0586  0790             //       :
0587  0791             //       : BUS_0 is pin 27 of J1
0588  0792             //       : BUS_1 is pin 25 of J1
0589  0793             //       : BUS_2 is pin 23 of J1
0590  0794             //       : BUS_3 is pin 21 of J1
0591  0795             //       : BUS_4 is pin 19 of J1
0592  0796             //       : BUS_5 is pin 17 of J1
0593  0797             //       : BUS_6 is pin 13 of J2
0594  0798             //       : BUS_7 is pin 11 of J2
0595  0799   
0596  0800             func bus_Set("var"), 0;
0597  0801             // Syntax: bus_Set(var);
0598  0802             // Usage : bus_Set(arg1);
0599  0803             // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
0600  0804             //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
0601  0805             //       : The upper 8 bits of arg1 are ignored.
0602  0806             //       : the BUS_RD and BUS_WR pins are not affected.
0603  0807             //       :
0604  0808             //       : BUS_0 is pin 27 of J1
0605  0809             //       : BUS_1 is pin 25 of J1
0606  0810             //       : BUS_2 is pin 23 of J1
0607  0811             //       : BUS_3 is pin 21 of J1
0608  0812             //       : BUS_4 is pin 19 of J1
0609  0813             //       : BUS_5 is pin 17 of J1
0610  0814             //       : BUS_6 is pin 13 of J2
0611  0815             //       : BUS_7 is pin 11 of J2
0612  0816   
0613  0817             func bus_Write("var"), 0;
0614  0818             // Syntax: bus_Write(var);
0615  0819             // Usage : bus_Write(arg1);
0616  0820             // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
0617  0821             //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
0618  0822             //       : LO for approx 50nsec then set back HI.
0619  0823             //       : The upper 8 bits of arg1 are ignored.
0620  0824             //       : NB:- the BUS_WR pin is automatically pre-set to an output to
0621  0825             //       : ensure BUS write integrity.
0622  0826             //       :
0623  0827             //       : BUS_0 is pin 27 of J1
0624  0828             //       : BUS_1 is pin 25 of J1
0625  0829             //       : BUS_2 is pin 23 of J1
0626  0830             //       : BUS_3 is pin 21 of J1
0627  0831             //       : BUS_4 is pin 19 of J1
0628  0832             //       : BUS_5 is pin 17 of J1
0629  0833             //       : BUS_6 is pin 13 of J2
0630  0834             //       : BUS_7 is pin 11 of J2
0631  0835   
0632  0836             func bus_Read(), 1;
0633  0837             // Syntax: bus_Read();
0634  0838             // Usage : arg1 := bus_Read();
0635  0839             // Notes : The BUS_RD pin set to LO, then, after a settling delay
0636  0840             //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
0637  0841             //       : (the upper 8 bits being set to 0)
0638  0842             //       : the BUS_RD pin is then set back to a HI level.
0639  0843             //       : NB:- the BUS_RD pin is automatically pre-set to an output to
0640  0844             //       : ensure BUS write integrity.
0641  0845             //       :
0642  0846             //       : BUS_0 is pin 27 of J1
0643  0847             //       : BUS_1 is pin 25 of J1
0644  0848             //       : BUS_2 is pin 23 of J1
0645  0849             //       : BUS_3 is pin 21 of J1
0646  0850             //       : BUS_4 is pin 19 of J1
0647  0851             //       : BUS_5 is pin 17 of J1
0648  0852             //       : BUS_6 is pin 13 of J2
0649  0853             //       : BUS_7 is pin 11 of J2
0650  0854   
0651  0855   
0652  0856             //------------------------------------------------------------------//
0653  0857             //   Graphics Functions
0654  0858             //------------------------------------------------------------------//
0655  0859             func gfx_Set("mode", "value"), 0;            // set various graphics functions
0656  0860             // Syntax: gfx_Set(mode, value);
0657  0861             // Usage : gfx_Set(arg1, arg2);
0658  0862             // Notes : Sets various graphics parameters used by other functions
0659  0863             //       : This allows the features to be set programatically with a
0660  0864             //       : single function call.It is strongly recommended to use the
0661  0865             //       : pre-defined constants rather than the mode numbers.
0662  0866             //       : NB:- Although it is often required to be able to set graphics
0663  0867             //       : functions with a single function call for graphics engine
0664  0868             //       : related functions, there is a complete set of single parameter
0665  0869             //       : shortcut functions that have exactly the same function as
0666  0870             //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
0667  0871             //       :
0668  0872             //       : mode = PEN_SIZE (mode 16)
0669  0873             //       : gfx_Set(PEN_SIZE, value);
0670  0874             //       : value = SOLID (value 0) rectangle and circle objects are solid
0671  0875             //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
0672  0876             //       : Sets the mode of the Pen used by most graphics objects
0673  0877             //       :
0674  0878             //       : mode = BACKGROUND_COLOUR (mode 17)
0675  0879             //       : gfx_Set(BACKGROUND_COLOUR, value);
0676  0880             //       : value = 0 to 0xFFFF, Black to White
0677  0881             //       : Sets the Background colour of the screen
0678  0882             //       :
0679  0883             //       : mode = OBJECT_COLOUR (mode 18)
0680  0884             //       : gfx_Set(OBJECT_COLOUR, value);
0681  0885             //       : value = 0 to 0xFFFF, Black to White
0682  0886             //       : Sets the Object colour used in various functions
0683  0887             //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
0684  0888             //       :
0685  0889             //       : mode = CLIPPING (mode 19)
0686  0890             //       : gfx_Set(CLIPPING, value);
0687  0891             //       : value = OFF (value 0) Clipping disabled
0688  0892             //       : value = ON (value 1) Clipping enabled
0689  0893             //       : Enables/Disables the Clipping feature
0690  0894             //       :
0691  0895             //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
0692  0896             //       : gfx_Set(TRANSPARENT_COLOUR, value);
0693  0897             //       : value = 0 to 0xFFFF Black to White
0694  0898             //       : Sets Bitmap, Image or Animation Transparency Colour.
0695  0899             //       : NB not implemented
0696  0900             //       :
0697  0901             //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
0698  0902             //       : gfx_Set(5, value);
0699  0903             //       : value = OFF (value 0) Transparency disabled
0700  0904             //       : value = ON (value 1) Transparency enabled
0701  0905             //       : Enables/Disables the Transparency feature
0702  0906             //       : NB not implemented
0703  0907             //       :
0704  0908             //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
0705  0909             //       : gfx_Set(FRAME_DELAY, value);
0706  0910             //       : value = 0 to 65535 ms
0707  0911             //       : Sets the Video/Animation clip inter-frame delay. This setting will
0708  0912             //       : over-ride the embedded frame delay of the clip. After the event,
0709  0913             //       : the setting will auto disable and if further inter-frame delays need
0710  0914             //       : overriding the setting must be re-issued.
0711  0915             //       :
0712  0916             //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
0713  0917             //       : gfx_Set(SCREEN_MODE, value);
0714  0918             //       : value = LANDSCAPE   (value 0)
0715  0919             //       : value = LANDSCAPE_R (value 1)
0716  0920             //       : value = PORTRAIT    (value 2)
0717  0921             //       : value = PORTRAIT_R  (value 3)
0718  0922             //       :
0719  0923             //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
0720  0924             //       : gfx_Set(OUTLINE_COLOUR, value);
0721  0925             //       : value = 1 to 0xFFFF, if 0, featre is OFF
0722  0926             //       : Sets the filled Rectangle or Circle objects outline colour
0723  0927             //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
0724  0928             //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
0725  0929             //       :
0726  0930             //       : Only supports variable contrast for uOLED Modules
0727  0931             //       : mode = CONTRAST (mode 25) : Contrast
0728  0932             //       : gfx_Set(CONTRAST, value);
0729  0933             //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
0730  0934             //       : when contrast=0, display is placed in low power mode.
0731  0935             //       : This function should be called with contrast=0 when
0732  0936             //       : powering down the module.
0733  0937             //       :
0734  0938             //       : mode = LINE_PATTERN (mode 26) : Line Pattern
0735  0939             //       : gfx_Set(LINE_PATTERN, value);
0736  0940             //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
0737  0941             //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
0738  0942             //       : a value of 0 turns the feature off
0739  0943             //       :
0740  0944             //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
0741  0945             //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
0742  0946             //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
0743  0947             //       : NB not implemented, default is COLOUR16
0744  0948             //       :
0745  0949             //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
0746  0950             //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
0747  0951             //       : sets the button and slider objects bevel width
0748  0952             //       :
0749  0953             //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
0750  0954             //       : gfx_Set(BEVEL_SHADOW , 5);
0751  0955             //       : sets the button and slider objects darken and lighten depth for the bevel colour
0752  0956             //       :
0753  0957             //       : mode = X_ORIGIN (mode 29) : set x offset for screen
0754  0958             //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
0755  0959             //       : sets the origin of drawn objects to a position other than 0,0
0756  0960             //       :
0757  0961             //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
0758  0962             //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
0759  0963             //       : sets the origin of drawn objects to a position other than 0,0
0760  0964   
0761  0965   
0762  0966             func gfx_Cls(), 0;                    // clear the screen
0763  0967             // Syntax: gfx_Cls();
0764  0968             // Usage : gfx_Cls();
0765  0969             // Notes : Clears the screen with current background colour
0766  0970   
0767  0971             func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
0768  0972             // Syntax: gfx_MoveTo(x, y);
0769  0973             // Usage : gfx_MoveTo(arg1, arg2);
0770  0974             // Notes : Moves the origin to a new x,y position
0771  0975   
0772  0976             func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
0773  0977             // Syntax: gfx_MoveRel(x, y);
0774  0978             // Usage : gfx_MoveRel(arg1, arg2);
0775  0979             // Notes : Moves the origin to a new x,y position
0776  0980             //       : relative to the current origing
0777  0981   
0778  0982             func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
0779  0983             // Syntax: gfx_LineTo(x1, y1);
0780  0984             // Usage : gfx_LineTo(arg1, arg2);
0781  0985             // Notes : Draws a Line from the origin x,y to x1,y1.
0782  0986             //       : The new origin is then set to x1, y1. Line colour needs
0783  0987             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0784  0988   
0785  0989             func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
0786  0990             // Syntax: gfx_LineRel(x1, y1);
0787  0991             // Usage : gfx_LineRel(arg1, arg2);
0788  0992             // Notes : Draws a Line from the origin x,y to x1,y1.
0789  0993             //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
0790  0994             //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
0791  0995   
0792  0996             func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
0793  0997             // Syntax: gfx_Line(x1, x2, y2, colr);
0794  0998             // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
0795  0999             // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
0796  1000   
0797  1001             func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
0798  1002             // Syntax: gfx_Line(x1, x2, y, colr);
0799  1003             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0800  1004             // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
0801  1005   
0802  1006             func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
0803  1007             // Syntax: gfx_Line(y1, y2, x, colr);
0804  1008             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0805  1009             // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
0806  1010   
0807  1011             func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
0808  1012             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
0809  1013             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0810  1014             // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
0811  1015             //       : bottom corner (x2,y2) on the screen.
0812  1016   
0813  1017             func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
0814  1018             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
0815  1019             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0816  1020             // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
0817  1021             //       : bottom corner (x2,y2) on the screen.
0818  1022   
0819  1023             func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
0820  1024             // Syntax: gfx_Circle(x, y, rad, colr);
0821  1025             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0822  1026             // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
0823  1027   
0824  1028             func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
0825  1029             // Syntax: gfx_Circle(x, y, rad, colr);
0826  1030             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0827  1031             // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
0828  1032   
0829  1033             func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
0830  1034             // Syntax: gfx_PutPixel(x, y, colr);
0831  1035             // Usage : gfx_PutPixel(arg1, arg2, arg3);
0832  1036             // Notes : Plots a coloured pixel on the screen at x,y location
0833  1037   
0834  1038             func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
0835  1039             // Syntax: gfx_GetPixel(x, y);
0836  1040             // Usage : var := gfx_GetPixel(arg1, arg2);
0837  1041             // Notes : Reads and returns the colour value of a pixel at location x,y
0838  1042   
0839  1043             func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
0840  1044             // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
0841  1045             // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0842  1046             // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0843  1047             //       : Vertices must be specified in an anti-clockwise fashion
0844  1048   
0845  1049             func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
0846  1050             // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
0847  1051             // Usage : gfx_OrbitInit(&arg1, &arg2);
0848  1052             // Notes : Sets up the Orbit function parameters.
0849  1053             //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
0850  1054             //       : variables that get updated after calling gfx_Orbit(,,) function.
0851  1055             //       : The coordiantaes are calculated relative to the origin
0852  1056             //       : obtained by using the gfx_MoveTo(x, y) function.
0853  1057   
0854  1058             func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
0855  1059             // Syntax: gfx_Orbit(angle, distance);
0856  1060             // Usage : gfx_Orbit(arg1, arg2);
0857  1061             // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
0858  1062             //       : only known parameters are the angle and the distance from the current origin.
0859  1063   
0860  1064             func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
0861  1065             // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
0862  1066             // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
0863  1067             // Notes : This function is very similar to the Ploygon function
0864  1068             //       : with the exception of the 1st and the last vertices not joined.
0865  1069   
0866  1070             func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
0867  1071             // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
0868  1072             // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
0869  1073             // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0870  1074             //       : Vertices must be minimum of 3 and can be specified in any fashion
0871  1075   
0872  1076             func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
0873  1077             // Syntax: gfx_Dot();
0874  1078             // Usage : gfx_Dot();
0875  1079             // Notes : Places a coloured dot at the origin
0876  1080   
0877  1081   
0878  1082             func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
0879  1083             // Syntax: gfx_Bullet();
0880  1084             // Usage : gfx_Bullet();
0881  1085             // Notes : Places a coloured circle at the origin
0882  1086             //       : filled or unfilled state is controlled by PenSize
0883  1087   
0884  1088             func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
0885  1089             // Syntax: gfx_IncX();
0886  1090             // Usage : var := gfx_IncX();
0887  1091             // Notes : Increments the x coordinate of the origin
0888  1092   
0889  1093             func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
0890  1094             // Syntax: gfx_IncY();
0891  1095             // Usage : var := gfx_IncY();
0892  1096             // Notes : Increments the y coordinate of the origin
0893  1097   
0894  1098             func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
0895  1099             // Syntax: gfx_BoxTo(x1, y1);
0896  1100             // Usage : gfx_BoxTo(arg1, arg2);
0897  1101             // Notes : Draws a Rectangle from the origin x,y to x1,y1.
0898  1102             //       : The new origin is then set to x1,y1. Rectangle colour needs
0899  1103             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0900  1104             //       : and the PenSize setting determines if Box is solid or outline.
0901  1105   
0902  1106             func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
0903  1107             // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
0904  1108             // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
0905  1109             // Notes : Specifies a clipping window region on the screen such that any objects
0906  1110             //       : and text placed onto the screen will be clipped and displayed only
0907  1111             //       : within that region. For the clipping window to take effect, "Clipping"
0908  1112             //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
0909  1113   
0910  1114   
0911  1115             func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
0912  1116             // Syntax: gfx_ChangeColour(oldcolr, newcolr);
0913  1117             // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
0914  1118             // *Notes:
0915  1119   
0916  1120             func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
0917  1121             // Syntax: gfx_SetClipRegion();
0918  1122             // Usage : var := gfx_SetClipRegion();
0919  1123             // *Notes:
0920  1124   
0921  1125             func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
0922  1126             // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
0923  1127             // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
0924  1128             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0925  1129             //       : with xradius = xrad and yradius = yrad.
0926  1130             //       : if PenSize = 0 Ellipse is Solid
0927  1131             //       : if PenSize = 1 Ellipse is Outline
0928  1132   
0929  1133   
0930  1134             func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
0931  1135             // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
0932  1136             // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
0933  1137             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0934  1138             //       : with xradius = xrad and yradius = yrad.
0935  1139   
0936  1140             func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
0937  1141             // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
0938  1142             // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
0939  1143             // Notes : Draws a 3 dimensional Text Button at screen location defined by
0940  1144             //       : x,y arguments (top left corner). The size of the button depends on
0941  1145             //       : the font, width, height and length of the text.
0942  1146             //       : The button appearance will depend on the state parameter setting:
0943  1147             //       :         state = 0 : Button Pressed
0944  1148             //       :         state = 1 : Button Raised
0945  1149   
0946  1150             func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
0947  1151             // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
0948  1152             // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
0949  1153             // Notes : Draws a panel (groupbox) at screen location defined by
0950  1154             //       : x, y, width and height with colour "colour".
0951  1155             //       :         state = 0 : recessed
0952  1156             //       :         state = 1 : raised
0953  1157   
0954  1158             func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
0955  1159             // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
0956  1160             // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0957  1161             // Notes : Draws a 3 dimensional Slider Bar on the screen.
0958  1162             //       : Slider parameters are as follows:
0959  1163             //       :         mode = 0 : Slider recessed
0960  1164             //       :         mode = 1 : Slider raised
0961  1165             //       :         x1, y1 = top left corner
0962  1166             //       :         x2, y2 = bottom right corner
0963  1167             //       :         scale = n : sets the full scale range from 0 to n
0964  1168             //       :         value = m : sets the relative position of the thumb 0 <= m <= n
0965  1169             //       : returns:-
0966  1170   
0967  1171   
0968  1172             func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
0969  1173             // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
0970  1174             // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
0971  1175             // Notes : Copies an area of a screen from xs,ys of size given by width and height
0972  1176             //       : and pastes it to another location determined by xd, yd.
0973  1177   
0974  1178             func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
0975  1179             // Syntax: gfx_RGBto565(red, green, blue);
0976  1180             // Usage : gfx_RGBto565(arg1, arg2, arg3);
0977  1181             // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
0978  1182   
0979  1183             func gfx_332to565("COLOUR8BIT"), 1;
0980  1184             // Syntax: gfx_332to565(colour);
0981  1185             // Usage : gfx_332to565(arg);
0982  1186             // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
0983  1187   
0984  1188             func gfx_Selection("index", "backcolor", "textcolor"), 0;
0985  1189             // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
0986  1190             // Usage : gfx_Selection(1, RED, YELLOW);
0987  1191             // Notes : Called prior to drawing a button, this function
0988  1192             //       : hilites the required text line on a multiline button.
0989  1193   
0990  1194             func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
0991  1195             // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
0992  1196             // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0993  1197             // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0994  1198             //       : Vertices must be specified in an anti-clockwise fashion
0995  1199   
0996  1200   
0997  1201             func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
0998  1202             // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
0999  1203             // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
1000  1204             // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
1001  1205             //       : Vertices must be minimum of 3 and can be specified in any fashion
1002  1206   
1003  1207   
1004  1208             func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
1005  1209             // Syntax: gfx_Offset(x, y);
1006  1210             // Usage : gfx_Offset(arg1, arg2);
1007  1211             // Notes : Set the screen offset
1008  1212   
1009  1213   
1010  1214   
1011  1215             func gfx_Get("mode"), 1;
1012  1216             // Syntax: gfx_Get(mode);
1013  1217             // Usage : arg1 := gfx_Get(arg);
1014  1218             // Notes : Returns various parameters to caller
1015  1219             //       :
1016  1220             //       : mode = X_MAX (mode 0) : current orientations maximum X value
1017  1221             //       : var := gfx_Get(X_MAX);
1018  1222             //       : Returns the maximum horizontal value of the display
1019  1223             //       :
1020  1224             //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
1021  1225             //       : var := gfx_Get(Y_MAX);
1022  1226             //       : Returns the maximum vertical value of the display
1023  1227             //       :
1024  1228             //       : mode = LEFT_POS (mode 2) : Left location of last Object
1025  1229             //       : var := gfx_Get(LEFT_POS);
1026  1230             //       : Returns the left location of the last drawn object
1027  1231             //       : such as a slider or button or an image/video
1028  1232             //       :
1029  1233             //       : mode = TOP_POS (mode 3) : Top location of Object
1030  1234             //       : var := gfx_Get(TOP_POS);
1031  1235             //       : Returns the top location of the last drawn object
1032  1236             //       : such as a slider or button or an image/video
1033  1237             //       :
1034  1238             //       : mode = RIGHT_POS (mode 4) : Right location of last Object
1035  1239             //       : var := gfx_Get(RIGHT_POS);
1036  1240             //       : Returns the right location of the last drawn object
1037  1241             //       : such as a slider or button or an image/video
1038  1242             //       :
1039  1243             //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
1040  1244             //       : var := gfx_Get(BOTTOM_POS );
1041  1245             //       : Returns the bottom location of the last drawn object
1042  1246             //       : such as a slider or button or an image/video
1043  1247             //       :
1044  1248   
1045  1249   
1046  1250             //==================================================//
1047  1251             // Single parameter short-cuts                      //
1048  1252             // for the gfx_Set functions                        //
1049  1253             // These functions return the existing value before //
1050  1254             // the change is made.                              //
1051  1255             //==================================================//
1052  1256             func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
1053  1257             func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
1054  1258             func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
1055  1259             func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
1056  1260             func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
1057  1261             func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
1058  1262             func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
1059  1263             func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
1060  1264             func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
1061  1265             func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
1062  1266             func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
1063  1267             func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
1064  1268             func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
1065  1269             func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
1066  1270             func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
1067  1271             func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
1068  1272   
1069  1273   
1070  1274             //==================================================//
1071  1275             // uSD/FLASH Function Prototypes                    //
1072  1276             //==================================================//
1073  1277             func media_Video("x", "y"), 0;                      // display movie at position x y
1074  1278             // Syntax: media_Video(x, y);
1075  1279             // Usage : media_Video(arg1, arg2);
1076  1280             // Notes : Play a Video/Animation clip from the uSD card at screen location
1077  1281             //       : specified by x,y (top left corner). The location of the clip in the
1078  1282             //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
1079  1283   
1080  1284             func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
1081  1285             // Syntax: media_VideoFrame(Frame_number);
1082  1286             // Usage : arg1 := media_VideoFrame();
1083  1287             // Notes : After a pointer to a valid video has been set with media_SetSector,
1084  1288             //       : calling this function shows each fram sequentially, returning
1085  1289             //       : the number of frames remaining. The position of the image is
1086  1290             //     : at the current origin as set with gfx_MoveTo(...);
1087  1291   
1088  1292             func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
1089  1293             // Syntax: media_SetAdd(AddHiWord, AddLoWord);
1090  1294             // Usage : media_SetAdd(arg1, arg2);
1091  1295             // Notes : Set uSD internal Address pointer for bytewise access
1092  1296   
1093  1297             func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
1094  1298             // Syntax: media_SetSector(SectHiWord, SectLoWord);
1095  1299             // Usage : media_SetSector(arg1, arg2);
1096  1300             // Notes : Set uSD internal Sector pointer for sector block access
1097  1301   
1098  1302             func media_RdSector("*destination"), 1;
1099  1303             // Syntax: media_RdSector(*destination);
1100  1304             // Usage : media_RdSector(rdblock);
1101  1305             // Notes : Reads and Returns 512 bytes (256 words) into a destination
1102  1306             //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
1103  1307             //       : After the read the Sector pointer is automatically incremented by 1.
1104  1308             //       : Returns TRUE if uSD response was TRUE
1105  1309   
1106  1310             func media_WrSector("*source"), 1;
1107  1311             // Syntax: media_WrSector(*source);
1108  1312             // Usage : media_WrSector(wrblock);
1109  1313             // Notes : Writes 512 bytes (256 words) from a source memory block
1110  1314             //       : (eg wrblock[256]) into the uSD card. After the write the Sector
1111  1315             //       : pointer is automatically incremented by 1.
1112  1316             //       : Returns TRUE if uSD response was TRUE
1113  1317   
1114  1318             func media_ReadByte(), 1;                // read a byte at the current stream position
1115  1319             // Syntax: media_RdByte();
1116  1320             // Usage : var := media_RdByte();
1117  1321             // Notes : Reads and Returns a single byte of data from the
1118  1322             //       : uSD card pointed to by the internal Address pointer.
1119  1323             //       : After the read the Address pointer is automatically
1120  1324             //       : incremented by 1.
1121  1325   
1122  1326             func media_ReadWord(), 1;                // read a word at the current stream position
1123  1327             // Syntax: media_ReadWord();
1124  1328             // Usage : var := media_ReadWord();
1125  1329             // *Notes : Reads and Returns a single word of data from the
1126  1330             //       : uSD card pointed to by the internal Address pointer.
1127  1331             //       : After the read the Address pointer is automatically
1128  1332             //       : incremented by 2.
1129  1333   
1130  1334             func media_WriteByte("byte"), 1;              // write a byte to the current stream position
1131  1335             // Syntax: media_WriteByte(arg1);
1132  1336             // Usage : var := media_WriteByte(arg1);
1133  1337             // *Notes : Writes and Returns xxxxx
1134  1338             //       : After the write the Address pointer is automatically
1135  1339             //       : incremented by 1.
1136  1340   
1137  1341             func media_WriteWord("word"), 1;            // write a word to the current stream position
1138  1342             // Syntax: media_WriteWord(arg1);
1139  1343             // Usage : var := media_WriteWord(arg1);
1140  1344             // *Notes : Writes and Returns xxxxx
1141  1345             //       : After the write the Address pointer is automatically
1142  1346             //       : incremented by 2.
1143  1347   
1144  1348             func media_Image("x", "y"), 0;            // display image at position x y
1145  1349             // Syntax: media_Image(x, y);
1146  1350             // Usage : media_Image(arg1, arg2);
1147  1351             // Notes : Display an image from the uSD card at screen location
1148  1352             //       : specified by x,y (top left corner). The location of the
1149  1353             //       : Image in the uSD card must be specified by
1150  1354             //       : media_setSector(Image_Sector_Add) function.
1151  1355   
1152  1356             func media_Flush(), 1;                    // after writing to media, flush the sector and write
1153  1357             // Syntax: media_Flush();
1154  1358             // Usage : var := media_Flush();
1155  1359             // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
1156  1360             //       : is being written is correctly stored back to the media else write operations may be unpredictable.
1157  1361   
1158  1362             func media_Init(), 1;                    // initialize uSD card
1159  1363             // Usage : media_Init();
1160  1364             // Notes : Initialise uSD CARD
1161  1365             //       : Response: 0 = No Card
1162  1366             //       :           1 = Card Initialised
1163  1367   
1164  1368   
1165  1369             //==============================================//
1166  1370             // Communications Function Prototypes           //
1167  1371             //==============================================//
1168  1372             func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
1169  1373             // Syntax: com_Init(buffer, bufsize, qualifier);
1170  1374             // Usage1: com_Init(mybuf, 20, 0);
1171  1375             // Usage2: com_Init(mybuf, 20, ':');
1172  1376             // Notes : initialize a serial capture buffer for the comms input
1173  1377             //       : The program must declare a var array as a circular buffer.
1174  1378             //       : Usage1 declares a circular buffer which will continually
1175  1379             //       : buffer characters.
1176  1380             //       : Usage2 must receive ':' before any characters will
1177  1381             //       : accumulate in the buffer.
1178  1382   
1179  1383             func com_Reset(), 0;                 // reset the comms receiver
1180  1384             // Syntax: com_Reset();
1181  1385             // Usage : com_Reset();
1182  1386             // Notes : reset comms to default polled mode
1183  1387   
1184  1388             func com_Count(), 1;                // return count of characters in receive buffer
1185  1389             // Syntax: com_Count();
1186  1390             // Usage : arg := com_Count();
1187  1391             // Notes : return count of buffered characters in buffer attachment
1188  1392   
1189  1393             func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
1190  1394             // Syntax: com_Full();
1191  1395             // Usage : if (com_Full() ,,,, go read buffer;
1192  1396             // Notes : return true if buffer full (not necessarily an error if
1193  1397             //       : buffer is sized to a packet size)
1194  1398   
1195  1399             func com_Error(), 1;                // return comms errors comms error occurred
1196  1400             // Syntax: com_Error();
1197  1401             // Usage : if (com_Error() ) ...... take recovery action;
1198  1402             // Notes : return non zero if any errors low level comms errors occured
1199  1403             // returns :
1200  1404             // bit0 = Receiver Overflow Error
1201  1405             // bit1 = Receiver Framing Error
1202  1406             // bit2 = Transmit Buffer Overflow
1203  1407   
1204  1408             func com_Sync(), 1;                // returns TRUE if qualifier has been received
1205  1409             // Syntax: com_Sync();
1206  1410             // Usage : com_Sync();
1207  1411             // return true if sync character has been received in com_Init("...") mode
1208  1412   
1209  1413   
1210  1414             func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
1211  1415             // Syntax: com_TXbuffer("buf", "bufsize", "pin");
1212  1416             // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
1213  1417             // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
1214  1418             // Notes : initialize a serial buffer for the COM0 output.
1215  1419             //       : The program must declare a var array as a circular buffer.
1216  1420             //       : When a TX buffer is declared for comms, the transmission
1217  1421             //       : of characters becomes non blocking. The only time
1218  1422             //       : blocking will occur is if the buffer has insufficient space
1219  1423             //       : to accept the next character, in which case the function
1220  1424             //       : will wait for buffer space to become available. If the
1221  1425             //       : TX buffer is no longer required, just set the buffer pointer
1222  1426             //       : to zero, the size in this case doesnt matter and is ignored.
1223  1427             //       : The function can resize or reallocated to another buffer at
1224  1428             //       : any time. The buffer is flushed before any changes are made.
1225  1429             //       : "pin" designates an IO pin to control a bi-directional 
1226  1430             //       : control device for half duplex mode. "pin" will go HI at the
1227  1431             //       : start of a transmission, and will return low after the final
1228  1432             //       : byte is transmitted. If not required, just set "pin" to zero.
1229  1433   
1230  1434   
1231  1435             func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
1232  1436             // Syntax: com_TXcount();
1233  1437             // Usage : arg := com_Count();
1234  1438             // Notes : return count of characters remaining in COM0 transmit buffer
1235  1439             //       : that was previously allocated with com_TXbuffer(...);
1236  1440   
1237  1441   
1238  1442             func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
1239  1443             // Syntax: com_TXemptyEvent(function);
1240  1444             // Usage : arg := com_TXemptyEvent();
1241  1445             // Notes : If a comms TX buffer that was previously allocated with
1242  1446             //       : com_TXbuffer(...);, this function can be used to set up
1243  1447             //       : a function to be called when the COM0 TX buffer is empty.
1244  1448             //       : This is useful for either reloading the TX buffer, setting
1245  1449             //       : or clearing a pin to change the direction of eg a RS485
1246  1450             //       : line driver, or any other form of traffic control.
1247  1451             //       : The event function must not have any parameters.
1248  1452             //       : To disable the event, simply call com_TXemptyEvent(0).
1249  1453             //       : com_TXbuffer(...); also resets any active event.
1250  1454             //       : com_TXemptyEvent returns any previous event function
1251  1455             //       : address, or zero if there was no previous function.
1252  1456   
1253  1457   
1254  1458             func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
1255  1459             // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
1256  1460             // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
1257  1461             // Notes : Expecting that a comms TX buffer that was previously allocated with
1258  1462             //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
1259  1463             //       : the buffer being sent wile it is being loaded. Mormally, when
1260  1464             //       : using buffered comms, the transmit process will begin
1261  1465             //       : immediately. This is often undesirable for 2 reasons,
1262  1466             //       : 1] you may wish to build a packet then send it later
1263  1467             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1264  1468             //       : as the FIFO buffer is constantly trying to empty while
1265  1469             //       : you are busy tring to fill it.
1266  1470             // return -1 if function is called illegally when TX comms is not buffered.
1267  1471             // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
1268  1472             // return 0 when argument is zero, eg com_TXbufferHold(OFF)
1269  1473   
1270  1474   
1271  1475             //=============================================================//
1272  1476             // Auxilliary Communications Function Prototypes
1273  1477             //=============================================================//
1274  1478             func com1_Init("buffer", "bufsize", "qualifier"), 0;
1275  1479             // Syntax: com_Init(buffer, bufsize, qualifier);
1276  1480             // Usage1: com_Init(mybuf, 20, 0);
1277  1481             // Usage2: com_Init(mybuf, 20, ':');
1278  1482             // Notes : initialize a serial capture buffer for the comms input
1279  1483             //       : The program must declare a var array as a circular buffer.
1280  1484             //       : Usage1 declares a circular buffer which will continually
1281  1485             //       : buffer characters.
1282  1486             //       : Usage2 must receive ':' before any characters will
1283  1487             //       : accumulate in the buffer.
1284  1488   
1285  1489             func com1_Reset(), 0;
1286  1490             // Syntax: com_Reset();
1287  1491             // Usage : com_Reset();
1288  1492             // Notes : reset comms receiver to default polled mode
1289  1493   
1290  1494             func com1_Count(), 1;
1291  1495             // Syntax: com_Count();
1292  1496             // Usage : arg := com_Count();
1293  1497             // Notes : return count of characters in receive buffer
1294  1498   
1295  1499             func com1_Full(), 1;
1296  1500             // Syntax: com_Full();
1297  1501             // Usage : if (com_Full() ,,,, go read buffer;
1298  1502             // Notes : return true if receive buffer full
1299  1503   
1300  1504             func com1_Error(), 1;
1301  1505             // Syntax: com_Error();
1302  1506             // Usage : if (com_Error() ) ...... take recovery action;
1303  1507             // Notes : return non zero if any level comms errors occured
1304  1508             // returns :
1305  1509             // bit0 = Receiver Overflow Error
1306  1510             // bit1 = Receiver Framing Error
1307  1511             // bit2 = Transmit Buffer Overflow
1308  1512   
1309  1513             func com1_Sync(), 1;
1310  1514             // Syntax: com_Sync();
1311  1515             // Usage : com_Sync();
1312  1516             // Notes : return true if sync character has been received in com_Init("...") mode
1313  1517   
1314  1518   
1315  1519             func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
1316  1520             // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
1317  1521             // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
1318  1522             // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
1319  1523             // Notes : initialize a serial buffer for the COM1 output.
1320  1524             //       : The program must declare a var array as a circular buffer.
1321  1525             //       : When a TX buffer is declared for comms, the transmission
1322  1526             //       : of characters becomes non blocking. The only time
1323  1527             //       : blocking will occur is if the buffer has insufficient space
1324  1528             //       : to accept the next character, in which case the function
1325  1529             //       : will wait for buffer space to become available. If the
1326  1530             //       : TX buffer is no longer required, just set the buffer pointer
1327  1531             //       : to zero, the size in this case doesnt matter and is ignored.
1328  1532             //       : The function can resize or reallocated to another buffer at
1329  1533             //       : any time. The buffer is flushed before any changes are made.
1330  1534             //       : "pin" designates an IO pin to control a bi-directional 
1331  1535             //       : control device for half duplex mode. "pin" will go HI at the
1332  1536             //       : start of a transmission, and will return low after the final
1333  1537             //       : byte is transmitted. If not required, just set "pin" to zero.
1334  1538   
1335  1539   
1336  1540             func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
1337  1541             // Syntax: com1_TXcount();
1338  1542             // Usage : arg := com1_Count();
1339  1543             // Notes : return count of characters remaining in COM1 transmit buffer
1340  1544             //       : that was previously allocated with com1_TXbuffer(...);
1341  1545   
1342  1546   
1343  1547             func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
1344  1548             // Syntax: com1_TXemptyEvent(function);
1345  1549             // Usage : arg := com1_TXemptyEvent();
1346  1550             // Notes : If a comms TX buffer that was previously allocated with
1347  1551             //       : com1_TXbuffer(...);, this function can be used to set up
1348  1552             //       : a function to be called when the COM1 TX buffer is empty.
1349  1553             //       : This is useful for either reloading the TX buffer, setting
1350  1554             //       : or clearing a pin to change the direction of eg a RS485
1351  1555             //       : line driver, or any other form of traffic control.
1352  1556             //       : The event function must not have any parameters.
1353  1557             //       : To disable the event, simply call com1_TXemptyEvent(0).
1354  1558             //       : com1_TXbuffer(...); also resets any active event.
1355  1559             //       : com1_TXemptyEvent returns any previous event function
1356  1560             //       : address, or zero if there was no previous function.
1357  1561   
1358  1562   
1359  1563             func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
1360  1564             // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
1361  1565             // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
1362  1566             // Notes : Expecting that a comms TX buffer that was previously allocated with
1363  1567             //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
1364  1568             //       : the buffer being sent wile it is being loaded. Mormally, when
1365  1569             //       : using buffered comms, the transmit process will begin
1366  1570             //       : immediately. This is often undesirable for 2 reasons,
1367  1571             //       : 1] you may wish to build a packet then send it later
1368  1572             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1369  1573             //       : as the FIFO buffer is constantly trying to empty while
1370  1574             //       : you are busy tring to fill it.
1371  1575             // return -1 if function is called illegally when TX comms is not buffered.
1372  1576             // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
1373  1577             // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
1374  1578   
1375  1579             func serin1(), 1;
1376  1580             // Syntax: serin1();
1377  1581             // Usage : char := serin1();
1378  1582             // Notes : return the next available character from COM1
1379  1583   
1380  1584             func serout1("char"), 0;
1381  1585             // Syntax: serout1("char");
1382  1586             // Usage : serout1(ch);
1383  1587             // Notes : send character to COM1
1384  1588   
1385  1589             func com_SetBaud("comport","baudrate/10"), 1;
1386  1590             // Syntax: com_SetBaud("comport","baudrate/10");
1387  1591             // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
1388  1592             // Notes : sets to any viable baud rate from 160 to 655350
1389  1593             // return true if baud rate was acceptable
1390  1594   
1391  1595   
1392  1596   
1393  1597             //==============================================//
1394  1598             // Display Access                               //
1395  1599             //==============================================//
1396  1600             func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
1397  1601                                                             // NB not available on current Picaso GFX2
1398  1602   
1399  1603             func disp_SetReg("register", "data"), 0;
1400  1604             // Syntax: display_SetReg(register, data);
1401  1605             // Usage : display_SetReg(arg1, arg2);
1402  1606             // Notes : Sets uLCD specific display driver registers. Refer
1403  1607             //       : to appropriate display driver data sheet.
1404  1608   
1405  1609             func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
1406  1610             // Syntax: disp_setGRAM(x1, y1, x2, y2);
1407  1611             // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
1408  1612             // Notes : Prepares the GRAM area for user access.
1409  1613             //       : Data can now be written with disp_GRAM.
1410  1614             //       : GRAM will be set accordingly for the correct screen mode.
1411  1615             //       : the LO word of the 32 bit pixel count is returned. This is
1412  1616             //       : usually all that is needed unlse GRAM area exceeds 256^2
1413  1617             //       : A copy of the 32bit value can be found in
1414  1618             //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
1415  1619   
1416  1620             func disp_WrGRAM("colour"), 0;
1417  1621             // Syntax: display_WrGRAM(colour);
1418  1622             // Usage : display_WrGRAM(arg);
1419  1623             // Notes : Data can be written to the GRAM consecutively using
1420  1624             //       : this function once the GRAM access window has been setup.
1421  1625   
1422  1626             func disp_WriteControl("value"), 0;             // write a control byte to the display
1423  1627             func disp_WriteWord("value"), 0;                // write a word to the display
1424  1628   
1425  1629   
1426  1630             func disp_ReadWord(), 1;                        // read a word from the display
1427  1631             // Syntax: disp_ReadWord();
1428  1632             // Usage : x:=disp_ReadWord();
1429  1633             // Notes : Read a word from the controller
1430  1634             // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
1431  1635             //       : print(disp_ReadWord());        // print ID
1432  1636             //       : (Many displays are write only)
1433  1637   
1434  1638                                                             //
1435  1639             //==============================================//
1436  1640             // unadorned SPI functions                      //
1437  1641             //==============================================//
1438  1642             func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
1439  1643             func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
1440  1644             func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
1441  1645             func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
1442  1646                                                             //
1443  1647             //==============================================//
1444  1648             // flash device specific functions              //
1445  1649             //==============================================//
1446  1650             func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
1447  1651             func flash_ID(), 1;                             // read ID code from FLASH device
1448  1652             func flash_BulkErase(), 0;                      // erase the entire FLASH device
1449  1653             func flash_BlockErase("block"), 1;              // erase the required 64k flash block
1450  1654                                                             //
1451  1655                                                             //
1452  1656             //==============================================//
1453  1657             // string and character size function           //
1454  1658             //==============================================//
1455  1659             func charwidth("char"), 1;                      // return width of a character in pixel units
1456  1660             func charheight("char"), 1;                     // return height of a character in pixel units
1457  1661             func strwidth("pointer"), 1;                    // return width of a string in pixel units
1458  1662             func strheight(), 1;                            // return height of a string in pixel units
1459  1663   
1460  1664   
1461  1665             //------------------------------------------------------------------//
1462  1666             //        I2C Function Prototypes
1463  1667             //------------------------------------------------------------------//
1464  1668             func I2C_Open("speed"), 0;
1465  1669             // Syntax: I2C_Open(speed),
1466  1670             // Usage : I2C_Open(I2C_MED);
1467  1671             // Notes : configures the I2C module
1468  1672             //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
1469  1673   
1470  1674             func I2C_Close(), 0;
1471  1675             // Syntax: I2C_Close();
1472  1676             // Usage : I2C_Close();
1473  1677             // Notes : disables the I2C1 module.
1474  1678   
1475  1679             func I2C_Start(), 1;
1476  1680             // Syntax: I2C_Start();
1477  1681             // Usage : I2C_Start();
1478  1682             // Notes : generates a Start condition.
1479  1683             //       : returns true if successful (usually ignored)
1480  1684   
1481  1685             func I2C_Stop(), 1;
1482  1686             // Syntax: I2C_Stop();
1483  1687             // Usage : I2C_Stop();
1484  1688             // Notes : generates a Stop condition.
1485  1689             //       : returns true if successful (usually ignored)
1486  1690   
1487  1691             func I2C_Restart(), 1;
1488  1692             // Syntax: I2C_Restart();
1489  1693             // Usage : I2C_Restart();
1490  1694             // Notes : generates a Restart condition.
1491  1695             //       : returns true if successful (usually ignored)
1492  1696   
1493  1697             func I2C_Read(), 1;
1494  1698             // Syntax: I2C_Read();
1495  1699             // Usage : ch := I2C_Read();
1496  1700             // Notes : reads a single byte from the I2C Bus.
1497  1701   
1498  1702             func I2C_Write("byte"), 1;
1499  1703             // Syntax: I2C_Write(byte);
1500  1704             // Usage : r := I2C_Write(ch);
1501  1705             // Notes : is used to write a byte to the I2C bus.
1502  1706             //       : Returns 0 if failed, 1 if no ack, 2 if ack
1503  1707   
1504  1708             func I2C_Ack(), 0;
1505  1709             // Syntax: I2C_Ack();
1506  1710             // Usage : I2C_Ack();
1507  1711             // Notes : generates the acknowledge condition.
1508  1712   
1509  1713             func I2C_Nack(), 0;
1510  1714             // Syntax: I2C_Nack();
1511  1715             // Usage : I2C_Nack();
1512  1716             // Notes : generates the negative acknowledge condition.
1513  1717   
1514  1718             func I2C_AckStatus(), 0;
1515  1719             // Syntax: I2C_AckStatus();
1516  1720             // Usage : r := I2C_AckStatus();
1517  1721             // Notes : returns the ACK status from the device.
1518  1722   
1519  1723             func I2C_AckPoll("control"), 1;
1520  1724             // Syntax: I2C_AckPoll();
1521  1725             // Usage : r := I2C_AckPoll(0xA0);
1522  1726             // Notes : waits for a device to return from ACK polling.
1523  1727   
1524  1728             func I2C_Idle(), 0;
1525  1729             // Syntax: I2C_Idle();
1526  1730             // Usage : I2C_Idle();
1527  1731             // Notes : waits until the I2C Bus is Inactive.
1528  1732   
1529  1733             func I2C_Gets("buffer", "size"), 1;
1530  1734             // Syntax: I2C_Gets("buffer", "size");
1531  1735             // Usage : r := I2C_Gets(mybuf, 16);
1532  1736             // Notes : only reads up to "size" characters into "buffer"
1533  1737             //       : Reads up to asciiz terminator including terminator
1534  1738   
1535  1739             func I2C_Getn("buffer", "size"), 1;
1536  1740             // Syntax: I2C_Gets("buffer", "size");
1537  1741             // Usage : r := I2C_Gets(mybuf, 16);
1538  1742             // Notes : reads "size" bytes into "buffer"
1539  1743             //       :
1540  1744   
1541  1745             func I2C_Puts("buffer"), 1;
1542  1746             // Syntax: I2C_Puts("buffer");
1543  1747             // Usage : r := I2C_Puts(mybuf);
1544  1748             // Notes : writes an asciiz string to the I2C device
1545  1749             //       : returns count of characters written
1546  1750   
1547  1751             func I2C_Putn("buffer", "count"), 1;
1548  1752             // Syntax: I2C_Putn("buffer","count");
1549  1753             // Usage : r := I2C_Puts(mybuf,10);
1550  1754             // Notes : writes up to "size" bytes to the I2C device
1551  1755             //       : returns number of bytes written
1552  1756   
1553  1757   
1554  1758             //------------------------------------------------------------------//
1555  1759             //        Image Control Function Prototypes
1556  1760             //------------------------------------------------------------------//
1557  1761             func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
1558  1762             // Syntax: img_SetPosition(handle, index, xpos, ypos);
1559  1763             // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
1560  1764             // Notes : set the position where the image will be displayed
1561  1765             //       : returns true if index was ok and function was successful.
1562  1766             //       : you may turn off an image so when img_Refresh is called,
1563  1767             //       : the image will not be shown
1564  1768   
1565  1769             func img_Enable("handle", "index"), 1;
1566  1770             // Syntax: img_Enable(handle, index);
1567  1771             // Usage : r := img_Enable(hImageList, imagenum);
1568  1772             // Notes : enable image in a image list
1569  1773             //       : returns true if index was ok and function was successful.
1570  1774             //       : this is the default state so when img_Refresh is called,
1571  1775             //       : all the images in the list will be shown
1572  1776             //       : if index is set to -1, all of the images are enabled
1573  1777   
1574  1778             func img_Disable("handle", "index"), 1;
1575  1779             // Syntax: img_Disable(handle, index);
1576  1780             // Usage : r := img_Disable(hImageList, imagenum);
1577  1781             // Notes : disable image in a image list
1578  1782             //       : returns true if index was ok and function was successful.
1579  1783             //       : you must turn off an image so when img_Refresh is called,
1580  1784             //       : the image will not be shown.
1581  1785             //       : if index is set to -1, all of the images are disabled
1582  1786   
1583  1787   
1584  1788             func img_Darken("handle", "index"), 1;
1585  1789             // Syntax: img_Darken(handle, index);
1586  1790             // Usage : r := img_Darken(hImageList, imagenum);
1587  1791             // Notes : darken image in a image list
1588  1792             //       : returns true if index was ok and function was successful.
1589  1793             //       : if index is set to -1, all of the images are darkened
1590  1794             //       : NB:- this feature will only work for the next refresh, then
1591  1795             //       : the image reverts back to normal when displayed again.
1592  1796   
1593  1797   
1594  1798             func img_Lighten("handle", "index"), 1;
1595  1799             // Syntax: img_Lighten(handle, index);
1596  1800             // Usage : r := img_Lighten(hImageList, imagenum);
1597  1801             // Notes : lighten image in a image list
1598  1802             //       : returns true if index was ok and function was successful.
1599  1803             //       : if index is set to -1, all of the images are lightened
1600  1804             //       : NB:- this feature will only work for the next refresh, then
1601  1805             //       : the image reverts back to normal when displayed again.
1602  1806   
1603  1807             func img_SetWord("handle", "index", "offset", "word"), 1;
1604  1808             // Syntax: img_SetWord(handle, index, offset, word);
1605  1809             // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
1606  1810             // Notes : set specified word (0-7) in a image entry
1607  1811             //       : returns TRUE if successful, return value usually ignored.
1608  1812   
1609  1813             func img_GetWord("handle", "index", "offset"), 1;
1610  1814             // Syntax: myvar := img_GetWord("handle", "index", "offset");
1611  1815             // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
1612  1816             // Notes : returns specified word (0-14) from an image entry
1613  1817             //       : refer to image control entry offsets.
1614  1818   
1615  1819             func img_Show("handle", "index"), 1;
1616  1820             // Syntax: img_Show(handle, index);
1617  1821             // Usage : display image entry (regardless of enable/disable)
1618  1822             //       : returns TRUE if successful, return value usually ignored.
1619  1823   
1620  1824             func img_SetAttributes("handle", "index","value"), 1;
1621  1825             // Syntax: img_SetAttributes("handle", "index","offset");
1622  1826             // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
1623  1827             // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
1624  1828             //       : of an image control entry. "value" refers to various bits in
1625  1829             //       : the image control entry (see image attribute flags).
1626  1830             //       : A '1' bit in the "value" field SETS the respective bit
1627  1831             //       : in the IMAGE_FLAGS field of the image control entry.
1628  1832             //       : returns TRUE if successful, return value usually ignored.
1629  1833   
1630  1834             func img_ClearAttributes("handle", "index","value"), 1;
1631  1835             // Syntax: img_ClearAttributes("handle", "index","offset");
1632  1836             // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
1633  1837             // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
1634  1838             //       : of an image control entry. "value" refers to various bits in
1635  1839             //       : the image control entry (see image attribute flags)
1636  1840             //       : a '1' bit in the "value" field CLEARS the respective bit
1637  1841             //       : in the IMAGE_FLAGS field of the image control entry.
1638  1842             //       : returns TRUE if successful, return value usually ignored.
1639  1843   
1640  1844             func img_Touched("handle", "index"), 1;
1641  1845             // Syntax: r := img_Touched(handle, index);
1642  1846             // Usage : img_Touched(hndl, 17);
1643  1847             //       : returns -1 if image not touched, or returns index
1644  1848             // Notes : if index is passed as -1, function tests all images,
1645  1849             //       : and returns -1 if image not touched, or returns index.
1646  1850   
1647  1851   
1648  1852   
1649  1853   
1650  1854             //------------------------------------------------------------------//
1651  1855             //        Timer Function Prototypes
1652  1856             //------------------------------------------------------------------//
1653  1857             func sys_T(), 1;
1654  1858             // Syntax: sys_T();
1655  1859             // Usage : t := sys_T();
1656  1860             // Notes : return the current value of the rolling system timer (1msec) LO word
1657  1861   
1658  1862             func sys_T_HI(), 1;
1659  1863             // Syntax: sys_T_HI();
1660  1864             // Usage : t := sys_T_HI();
1661  1865             // Notes : return the current value of the rolling system timer (1msec) HI word
1662  1866   
1663  1867             func sys_SetTimer("timernum","value"), 0;
1664  1868             // Syntax: sys_SetTimer("timernum", "value");
1665  1869             // Usage : sys_SetTimer(TIMER5, 10000);
1666  1870             // Notes : set a countdown on the selected timer, or 'top up' if required.
1667  1871             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1668  1872             //       : Maximum timeout period is 65.535 seconds
1669  1873             //       : A timer can be read with the sys_GetTimer("timernum") function
1670  1874   
1671  1875             func sys_GetTimer("timernum"), 1;
1672  1876             // Syntax: t := sys_GetTimer("timernum");
1673  1877             // Usage : t := sys_GetTimer(TIMER3);
1674  1878             // Notes : returns 0 if timer has expired, or the current countdown value.
1675  1879             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1676  1880             //       : Maximum timeout period is 65.535 seconds
1677  1881             //       : A timer must be set with the sys_SetTimer("timernum","value") function
1678  1882   
1679  1883             func sys_SetTimerEvent("timernum","function"), 1;
1680  1884             // Syntax: sys_SetTimerFunction("timernum", "function");
1681  1885             // Usage : sys_SetTimer(TIMER5, myfunc);
1682  1886             // Notes : set a function to be called for selected timer.
1683  1887             //       : When the timer reaches zero, the function is called.
1684  1888             //       : The called function must not have any parameters
1685  1889             //       : sys_SetTimerEvent returns any previous event function
1686  1890             //       : address, or zero if there was no previous function.
1687  1891   
1688  1892             func sys_EventQueue(), 1;
1689  1893             // Syntax: sys_EventQueue();
1690  1894             // Usage : tasks := sys_EventQueue();
1691  1895             // Notes : returns the max number of events that were pending
1692  1896             //       : in the timer queue since the last call to this function.
1693  1897             //       : This can be used to assess timer event overhead burden,
1694  1898             //       : especially after or during a sys_EventsPostpone action.
1695  1899   
1696  1900             func sys_EventsPostpone(), 0;
1697  1901             // Syntax: sys_EventPostpone();
1698  1902             // Usage : sys_EventPostpone();   // postpone the event queue
1699  1903             // Notes : postpone any events until the sys_EventResume function is executed
1700  1904             //       : The timer event queue will continue to queue events, but no action
1701  1905             //       : will take place untill a sys_EventResume function is encountered.
1702  1906             //       : The queue will continue to receive up to 32 events before discarding
1703  1907             //       : any further events. This function is required to allow a sequence of
1704  1908             //       : instructions or functions to occur that would otherwise be corrupted
1705  1909             //       : by an event occuring during the sequence of instructions or functions.
1706  1910             //       : A good example of this is when you set a position to print, if there
1707  1911             //       : was no way of locking the current sequence, an event may occur which
1708  1912             //       : does a similar thing, and a contention would occur - printing to
1709  1913             //       : the wrong position. This function should be used wisely, if any action
1710  1914             //       : that is required would take considerable time, it is better to disable
1711  1915             //       : any conflicting event functions with a bypass flag, then restart the
1712  1916             //       : conflicting event by re-issuing a timer value.
1713  1917   
1714  1918             func sys_EventsResume(), 0;
1715  1919             // Syntax: sys_EventsResume();
1716  1920             // Usage : sys_EventsResume();   // resume the event queue
1717  1921             // Notes : resume any postponed events. The queue will try to execute any timer
1718  1922             //       : events that were incurred during the postponed period.
1719  1923   
1720  1924   
1721  1925             func sys_Sleep("units"), 1;
1722  1926             // Syntax: t := sys_Sleep("units");
1723  1927             // Usage : t := sys_Sleep(10);
1724  1928             // Notes : sets the display into low power mode for a period of time.
1725  1929             //       : Touching the touch screen will also wake from sleep.
1726  1930             //       : Returns remaining sleep units.
1727  1931   
1728  1932             func iterator("offset"), 0;
1729  1933             // Syntax: t :=  iterator("offset");
1730  1934             // Usage : t :=  iterator(10);
1731  1935             // Notes : set the iterator size for ++/--
1732  1936             //       : The next postinc,postdec,preinc of predec will alter
1733  1937             //       : by the specified value.
1734  1938             //       : The offset will return to 1 after the next operation.
1735  1939   
1736  1940   
1737  1941   
1738  1942   
1739  1943             //------------------------------------------------------------------//
1740  1944             //         Touch Screen Function Prototypes
1741  1945             //------------------------------------------------------------------//
1742  1946   
1743  1947             func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
1744  1948             // Syntax: touch_DetectRegion(x1, y1, x2, y2);
1745  1949             // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
1746  1950             // Notes : Specifies a new touch detect region on the screen
1747  1951             //       : such that only touch activity in that region will
1748  1952             //       : be reported by the status poll touch_Get(TOUCH_STATUS);
1749  1953   
1750  1954             func touch_Set("mode"), 0;
1751  1955             // Syntax: touch_Set(mode);
1752  1956             // Usage : touch_Set(arg);
1753  1957             // Notes : Sets various Touch Screen related parameters
1754  1958             //       :
1755  1959             //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
1756  1960             //       : touch_Set(TOUCH_ENABLE);
1757  1961             //       : Enables and initialises Touch Screen hardware
1758  1962             //       :
1759  1963             //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
1760  1964             //       : touch_Set(TOUCH_DISABLE );
1761  1965             //       : Disables the Touch Screen
1762  1966             //       : Note: Touch Screen runs in the background and disabling
1763  1967             //       : it when not in use will free up extra resources
1764  1968             //       : such as 4DVM CPU cycles.
1765  1969             //       :
1766  1970             //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
1767  1971             //       : touch_Set(TOUCH_REGIONDEFAULT);
1768  1972             //       : This will reset the current active region to default
1769  1973             //       : to the full screen without the application having to
1770  1974             //       : set a new active region for the full screen.
1771  1975             //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
1772  1976             //       : that requre to be interfaced with an external pointing
1773  1977             //       : device, values that are poked into TOUCH_DRIVE will be
1774  1978             //       : read with the touch_Get() function)
1775  1979   
1776  1980   
1777  1981             func touch_Get("mode"), 1;
1778  1982             // Syntax: touch_Get(mode);
1779  1983             // Usage : arg1 := touch_Get(arg);
1780  1984             // Notes : Returns various Touch Screen parameters to caller
1781  1985             //       :
1782  1986             //       : mode = TOUCH_STATUS  (mode 0)
1783  1987             //       : var := touch_Get(TOUCH_STATUS);
1784  1988             //       : Returns the various states of the touch screen
1785  1989             //       : 0 = NOTOUCH
1786  1990             //       : 1 = TOUCH_PRESSED
1787  1991             //       : 2 = TOUCH_RELEASED
1788  1992             //       : 3 = TOUCH_MOVING
1789  1993             //       :
1790  1994             //       : mode = TOUCH_GETX   (mode 1)
1791  1995             //       : var := touch_Get(TOUCH_GETX);
1792  1996             //       : Returns the X coordinates of the touch
1793  1997             //       :
1794  1998             //       : mode = TOUCH_GETY   (mode 2)
1795  1999             //       : var := touch_Get(TOUCH_GETY);
1796  2000             //       : Returns the Y coordinates of the touch
1797  2001   
1798  2002             //------------------------------------------------------------------//
1799  2003             //        CTYPE Function Prototypes
1800  2004             //------------------------------------------------------------------//
1801  2005   
1802  2006             func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
1803  2007             // Syntax: isdigit("char");
1804  2008             // Usage : Var := isdigit(ch);
1805  2009             // Notes : char specifies the ascii character for the test
1806  2010             //     : 0 : char is not an ascii digit.
1807  2011             //     : 1 : char is an ascii digit..
1808  2012             //     : Valid range is "0123456789"
1809  2013   
1810  2014             func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
1811  2015             // Syntax: isxdigit("char");
1812  2016             // Usage : Var := isxdigit(ch);
1813  2017             // Notes : char specifies the ascii character for the test
1814  2018             //     : 0 : char is not an ascii hexadecimal digit.
1815  2019             //     : 1 : char is an ascii hexadecimal digit..
1816  2020             //     : Valid range is "0123456789ABCDEF"
1817  2021   
1818  2022             func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
1819  2023             // Syntax: isupper("char");
1820  2024             // Usage : Var := isupper(ch);
1821  2025             // Notes : char specifies the ascii character for the test
1822  2026             //     : 0 : char is not an ascii upper-case letter.
1823  2027             //     : 1 : char is an ascii upper-case letter.
1824  2028             //     : Valid range is "ABCD....WXYZ"
1825  2029   
1826  2030             func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
1827  2031             // Syntax: islower("char");
1828  2032             // Usage : Var := islower(ch);
1829  2033             // Notes : char specifies the ascii character for the test
1830  2034             //     : 0 : char is not an ascii lower-case letter.
1831  2035             //     : 1 : char is an ascii lower-case letter.
1832  2036             //     : Valid range is "abcd....wxyz"
1833  2037   
1834  2038             func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
1835  2039             // Syntax: isalpha("char");
1836  2040             // Usage : Var := isalpha(ch);
1837  2041             // Notes : char specifies the ascii character for the test
1838  2042             //     : 0 : char is not an ascii lower or upper case letter.
1839  2043             //     : 1 : char is an ascii lower or upper case letter.
1840  2044             //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
1841  2045   
1842  2046             func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
1843  2047             // Syntax: isalnum("char");
1844  2048             // Usage : Var := isalnum(ch);
1845  2049             // Notes : char specifies the ascii character for the test
1846  2050             //     : 0 : char is not an ascii alphanumeric character.
1847  2051             //     : 1 : char is an ascii alphanumeric character.
1848  2052             //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
1849  2053   
1850  2054             func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
1851  2055             // Syntax: isprint("char");
1852  2056             // Usage : Var := isprint(ch);
1853  2057             // Notes : char specifies the ascii character for the test
1854  2058             //     : 0 : char is not a printable ascii character.
1855  2059             //     : 1 : char is a printable ascii character.
1856  2060             //     : Valid range is "0x20...0x7F"
1857  2061   
1858  2062             func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
1859  2063             // Syntax: isspace("char");
1860  2064             // Usage : Var := isspace(ch);
1861  2065             // Notes : char specifies the ascii character for the test
1862  2066             //     : 0 : char is not a space type character.
1863  2067             //     : 1 : char is a space type character.
1864  2068             //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
1865  2069   
1866  2070             //unformatted
1867  2071             func iswhite("char"), 1;    //
1868  2072             // Syntax: iswhite("char");
1869  2073             // Usage : Var := iswhite(ch);
1870  2074             // Notes : char specifies the ascii character for the test
1871  2075             //     : 0 : char is not a space or tab character.
1872  2076             //     : 1 : char is not a space or tab character.
1873  2077             //     : Valid range is space or tab
1874  2078   
1875  2079             func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
1876  2080             // Syntax: toupper("char");
1877  2081             // Usage : Var := toupper(ch);
1878  2082             // Notes : char specifies the ascii character for the test
1879  2083             //     : "ABCD....XYZ" : if character is a lower case letter.
1880  2084             //     : char : if character is not a lower case letter.
1881  2085             //     : Valid range is "abcd....wxyz"
1882  2086   
1883  2087             func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
1884  2088             // Syntax: tolower("char");
1885  2089             // Usage : Var := tolower(ch);
1886  2090             // Notes : char specifies the ascii character for the test
1887  2091             //     : "abcd....xyz" : if character is an upper case letter.
1888  2092             //     : char : if character is not an upper case letter.
1889  2093             //     : Valid range is "ABCD....WXYZ"
1890  2094   
1891  2095             func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
1892  2096             // Syntax: LObyte(var);
1893  2097             // Usage : myVar := LObyte(myvar2);
1894  2098             // Notes : var specifies the user variable
1895  2099             //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
1896  2100   
1897  2101             func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
1898  2102             // Syntax: HIbyte(var);
1899  2103             // Usage : myVar := HIbyte(myvar2);
1900  2104             // Notes : var specifies the user variable
1901  2105             //     : Returns the high byte (upper 8 bits) of a 16 bit variable
1902  2106   
1903  2107   
1904  2108             func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
1905  2109             // Syntax: ByteSwap(var);
1906  2110             // Usage : myVar := ByteSwap(myvar2);
1907  2111             // Notes : var specifies the user variable
1908  2112             //     : Returns the endian swapped value of a 16 bit variable
1909  2113   
1910  2114   
1911  2115             //------------------------------------------------------------------//
1912  2116             //        Memory Allocation Function Prototypes
1913  2117             //------------------------------------------------------------------//
1914  2118   
1915  2119             func mem_Alloc("size"), 1;
1916  2120             // Syntax: mem_Alloc(bytesize);
1917  2121             // Usage : myvar := mem_Alloc(100);
1918  2122             // Notes : Allocate a block of memory to pointer myvar
1919  2123             //       : The allocated memory contains garbage but is a fast allocation.
1920  2124             //       : The block must later be released with mem_Free();
1921  2125             //       : returns 0 if function fails
1922  2126   
1923  2127             func mem_AllocV("size"), 1;
1924  2128             // Syntax: mem_AllocV(bytesize);
1925  2129             // Usage : myvar := mem_AllocV(100);
1926  2130             // Notes : Allocate a block of memory to pointer myvar
1927  2131             //       : The block of memory is filled with signature values
1928  2132             //       : the block starts with A5,5A then fills with incrementing
1929  2133             //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
1930  2134             //       : This can be helpful when debugging
1931  2135             //       : The block must later be released with mem_Free();
1932  2136             //       : returns 0 if function fails
1933  2137   
1934  2138             func mem_AllocZ("size"), 1;
1935  2139             // Syntax: mem_AllocZ(bytesize);
1936  2140             // Usage : myvar := mem_AllocC(100);
1937  2141             // Notes : Allocate a zeroed block of memory to pointer myvar
1938  2142             //       : The block of memory is filled with zeroes
1939  2143             //       : The block must later be released with mem_Free();
1940  2144             //       : returns 0 if function fails
1941  2145   
1942  2146             func mem_Realloc("ptr", "size"), 1;
1943  2147             // Syntax: myvar := mem_Realloc("ptr", "size");
1944  2148             // Usage : myvar := mem_Realloc(ptr, size);
1945  2149             // Notes : The function may move the memory block to a new location,
1946  2150             //       : in which case the new location is returned.
1947  2151             //       : The content of the memory block is preserved up to the lesser
1948  2152             //       : of the new and old sizes, even if the block is moved.
1949  2153             //       : If the new size is larger, the value of the newly allocated
1950  2154             //       : portion is indeterminate. In case that ptr is NULL,
1951  2155             //       : the function behaves exactly as mem_Alloc, assigning a new block
1952  2156             //       : of size bytes and returning a pointer to the beginning of it.
1953  2157             //       : In case that the size is 0, the memory previously allocated in
1954  2158             //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
1955  2159             //       : pointer is returned.
1956  2160   
1957  2161             func mem_Free("allocation"), 1;
1958  2162             // Syntax: myvar := mem_Free(allocation);
1959  2163             // Usage : myvar := mem_Free(myvar);
1960  2164             // Notes : De-allocate a block of memory previously created with
1961  2165             //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
1962  2166             //       : returns 0 if function fails
1963  2167   
1964  2168             func mem_Heap(), 1;
1965  2169             // Syntax: myvar := mem_Heap();
1966  2170             // Usage : myvar := mem_Heap();
1967  2171             // Notes : returns bytecount available in heap
1968  2172             //       :
1969  2173   
1970  2174             func mem_Set("ptr","char","size"), 1;
1971  2175             // Syntax: mem_Set(ptr,char,bytesize);
1972  2176             // Usage : mem_Set(p, 'A', 100);
1973  2177             // Notes : fill a block of memory with a byte value
1974  2178             //       : returns ptr
1975  2179   
1976  2180             func mem_Copy("src", "dest", "bytecount"), 1;
1977  2181             // Syntax: myvar := mem_Copy(src, dest, bytesize);
1978  2182             // Usage : myvar := mem_Copy(p1, p2, 100);
1979  2183             // Notes : copy a word aligned block of memory from src to dest
1980  2184             //       : Note that count is a byte count, this facilitates
1981  2185             //       : copying word aligned byte arrays when using word
1982  2186             //       : aliggned packed strings.
1983  2187             //       : returns src
1984  2188   
1985  2189             func mem_Compare("ptr1","ptr2","count"), 1;
1986  2190             // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
1987  2191             // Usage : myvar := mem_Compare(p1, p2, 100);
1988  2192             // Notes : compare blocks of memory at src, dest
1989  2193             //       : returns 0 if we have a match
1990  2194   
1991  2195             //------------------------------------------------------------------//
1992  2196             //        FAT16 Function Prototypes
1993  2197             //------------------------------------------------------------------//
1994  2198   
1995  2199             func file_Error(), 1;
1996  2200             // Syntax: myvar := file_Error();
1997  2201             // Usage : e := file_Error();
1998  2202             // Notes : return the most recent file error.
1999  2203             //       :
2000  2204   
2001  2205             func file_Count("filename"), 1;
2002  2206             // Syntax: count := file_Count("filename");
2003  2207             // Usage : count := file_Count("*.4dg");
2004  2208             // Notes : returns number of files found that match the criteria
2005  2209   
2006  2210             func file_Dir("filename"), 1;
2007  2211             // Syntax: count := file_Dir("filename");
2008  2212             // Usage : count := file_Dir("*.4dg");
2009  2213             // Notes : streams a string of filenames that agree with the search key
2010  2214             //       : returns number of files found that match the criteria
2011  2215   
2012  2216             func file_FindFirst("fname"), 1;
2013  2217             // Syntax: res := file_FindFirst("fname");
2014  2218             // Usage : if (file_FindFirst("*.4xe") ....
2015  2219             // Notes : returns true if at least 1 file exists
2016  2220             //       : that satisfies the file argument.
2017  2221             //       : Wildcards are usually used so if
2018  2222             //       : file_FindFirst returns true, further
2019  2223             //       : tests can be made using file_FindNext();
2020  2224             //       : to find all the files that match the
2021  2225             //       : wildcard class. Note that the stream behaviour
2022  2226             //       : is the same as file_Dir.
2023  2227             //       :
2024  2228   
2025  2229             func file_FindNext(), 1;
2026  2230             // Syntax: res := file_FindNext();
2027  2231             // Usage : while ((file_FindNext()) ....
2028  2232             // Notes : returns true if more file exists
2029  2233             //       : that satisfies the file argument
2030  2234             //       : that was given for  file_FindFirst.
2031  2235             //       : Wildcards must be used for
2032  2236             //       : file_FindFirst, else this function will
2033  2237             //       : always return zero as the only occurence
2034  2238             //       : will have already been found.
2035  2239             //       : Note that the stream behaviour
2036  2240             //       : is the same as file_Dir.
2037  2241             //       :
2038  2242   
2039  2243             func file_Exists("fname"), 1;
2040  2244             // Syntax: res := file_Exists("fname"),
2041  2245             // Usage : if(file_Exists("myfile") ....
2042  2246             // Notes : returns true if file exists
2043  2247             //       :
2044  2248   
2045  2249             func file_Open("fname", "mode"), 1;
2046  2250             // Syntax: handle := file_Open("fname","mode"),
2047  2251             // Usage : handle := file_Open("myfile.txt", 'r');
2048  2252             // Notes : returns handle if file exists
2049  2253             //       :
2050  2254   
2051  2255             func file_Close("handle"), 1;
2052  2256             // Syntax: res := file_Close("handle");
2053  2257             // Usage : res := file_Close(hnd1);
2054  2258             // Notes : returns true if file closed ok
2055  2259             //       :
2056  2260   
2057  2261             func file_Read("*dest", "size", "handle"), 1;
2058  2262             // Syntax: res := file_Read("*dest", "size", "handle"),
2059  2263             // Usage : res := file_Read(memblock,20,hnd1);
2060  2264             // Notes : returns number of characters read
2061  2265             //       : if "dest" is zero, data is read direct to GRAM window
2062  2266             //       :
2063  2267   
2064  2268   
2065  2269             func file_Seek("handle", "HiWord", "LoWord"), 1;
2066  2270             // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
2067  2271             // Usage : res := file_Seek(hSource, 0, 0x1234);
2068  2272             // Notes : set file position to 0x00001234 (byte position 4660)
2069  2273             //       : for the file handle so subsequent data may be read
2070  2274             //       : from that position onwards with file_GetC(...),
2071  2275             //       : file_GetW(...) or file_GetS(...), or an image
2072  2276             //       : can be displayed with file_Image(...)
2073  2277             // Notes : returns true if ok, usually ignored
2074  2278   
2075  2279             func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
2076  2280             // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
2077  2281             // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
2078  2282             // Notes : set file seek position to 123000
2079  2283             //       : for the file handle so subsequent data may be read
2080  2284             //       : from that record position onwards with file_GetC(...),
2081  2285             //       : file_GetW(...) or file_GetS(...), or an image
2082  2286             //       : can be displayed with file_Image(...)
2083  2287             // Notes : returns true if ok, usually ignored
2084  2288   
2085  2289             func file_Tell("handle", "&HiWord", "&LoWord"), 1;
2086  2290             // Syntax: file_Tell("handle", &HiWord, &LoWord);
2087  2291             // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
2088  2292             // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
2089  2293             //       : returns true if function succeeded
2090  2294   
2091  2295             func file_Write("*source", "size", "handle"), 1;
2092  2296             // Syntax: res := fwrite("*source", "size", "handle"),
2093  2297             // Usage : res := fwrite(memblock, 20, hnd1);
2094  2298             // Notes : returns number of bytes written
2095  2299             //       :
2096  2300   
2097  2301             func file_Size("handle", "&HiWord", "&LoWord"), 1;
2098  2302             // Syntax: file_Size("handle", &HiWord, &LoWord);
2099  2303             // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
2100  2304             // Notes : Reads the 32 bit file size and stores it into 2 variables.
2101  2305             //       : returns true if function succeeded
2102  2306   
2103  2307             func file_Image("x", "y", "handle"), 1;
2104  2308             // Syntax: file_Image(x, y, handle);
2105  2309             // Usage : file_Image(10, 10, hnd1);
2106  2310             // Notes : Display an image from a file at the current file position.
2107  2311             //       : The image is displayed at x,y (with respect to top left corner).
2108  2312             //       : If there is more than 1 image in the file, it can be
2109  2313             //       : accessed with file_Seek(...)
2110  2314   
2111  2315             func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
2112  2316             // Syntax: file_ScreenCapture(x, y, w, h, handle);
2113  2317             // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
2114  2318             // Notes : Save a image from screen to file at the current file position.
2115  2319             //       : The image can later be displayed with file_Image(...);
2116  2320             //       : The file may be opened in append mode to accumulate multiple
2117  2321             //       : images. Later, the images can be accessed with file_Seek(...);
2118  2322             //       : Note that the image will be sector aligned.
2119  2323             //       : All image headers must start on a sector boundary.
2120  2324             //       : The image is saved from x, y (with respect to top left corner)
2121  2325             //       : and the capture area is determined by "width" and "height".
2122  2326             //       : returns 0 if function succeeded
2123  2327   
2124  2328             func file_PutC("char","handle"), 1;
2125  2329             // Syntax: file_PutC("char", "handle");
2126  2330             // Usage : file_PutC('x', hndl);
2127  2331             // Notes : returns true if function succeeded
2128  2332   
2129  2333             func file_GetC("handle"), 1;
2130  2334             // Syntax: file_GetC("handle");
2131  2335             // Usage : mychar := fgetC("handle");
2132  2336             // Notes : returns next char from file
2133  2337   
2134  2338             func file_PutW("word","handle"), 1;
2135  2339             // Syntax: file_PutW("word","handle");
2136  2340             // Usage : file_PutW(0x1234, hndl);
2137  2341             // Notes : returns true if function succeeded
2138  2342   
2139  2343             func file_GetW("handle"), 1;
2140  2344             // Syntax: file_GetW("handle");
2141  2345             // Usage : myword := fgetW("handle");
2142  2346             // Notes : returns next word in file
2143  2347   
2144  2348             func file_PutS("*source", "handle"), 1;
2145  2349             // Syntax: res := file_Puts("*source", "handle"),
2146  2350             // Usage : res := file_Puts(mystring, hnd1);
2147  2351             // Notes : returns number of characters written
2148  2352             //       :
2149  2353   
2150  2354             func file_GetS("*string", "size", "handle"), 1;
2151  2355             // Syntax: res := file_Gets("*string", "size", "handle");
2152  2356             // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
2153  2357             // Notes : get a string from a file
2154  2358             //       : returns pointer to string or null if failed.
2155  2359             //       : file_GetS(...) automatically appends a null-terminator to the data read.
2156  2360             //       : NB:- only reads up to "size-1" characters into "string"
2157  2361             //       : file_GetS(...) will stop reading when any of the following conditions are true:
2158  2362             //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
2159  2363             //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
2160  2364             //       : C] It reaches the end of file
2161  2365             //       : D] A read error occurs.
2162  2366   
2163  2367   
2164  2368             func file_Erase("fname"), 1;
2165  2369             // Syntax: res := file_Erase("fname");
2166  2370             // Usage : res := file_Erase("myfile.txt");
2167  2371             // Notes : returns true if successful
2168  2372             //       :
2169  2373   
2170  2374             func file_Rewind("handle"), 1;
2171  2375             // Syntax: res := file_Rewind("handle");
2172  2376             // Usage : res := file_Rewind(hnd1);
2173  2377             // Notes : returns true if file rewound ok (usually ignored)
2174  2378             //       : resets the file pointer the the beginning of the open file.
2175  2379   
2176  2380             func file_LoadFunction("fname.4xe"), 1;
2177  2381             // Syntax: res := file_LoadFunction("fname.4fn");
2178  2382             // Usage : myfunc := file_LoadFunction(myfuncname);
2179  2383             // Notes : Load a function or program from disk and
2180  2384             //       : return a function pointer to the allocation.
2181  2385             //       : The function can then be invoked just like any other
2182  2386             //       : function would be called via a function pointer.
2183  2387             //       : Parameters may be passed to it in a conventional way.
2184  2388             //       : The function may be discarded at any time when no
2185  2389             //       : longer required, thus freeing its memory resources.
2186  2390             //       : The loaded function can be discarded with mem_Free(..)
2187  2391             //       : eg:
2188  2392             //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
2189  2393             //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
2190  2394             //       : then elsewhere in your program:-
2191  2395             //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
2192  2396             //       : if(res == QUIT_APPLICATION) goto exitApp;
2193  2397             //       : Later in your program, when popupWindow is no longer
2194  2398             //       : required for the application:-
2195  2399             //       : res := mem_Free(popupWindow);
2196  2400             //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
2197  2401             //       : The callers stack is shared by the loaded function,
2198  2402             //       : however any global variables in the loaded function
2199  2403             //       : are private to that function.
2200  2404             //
2201  2405   
2202  2406             func file_Run("fname.4xe", "arglistptr"), 1;
2203  2407             // Syntax: res := file_Run("fname.4xe","arglistptr");
2204  2408             // Usage : res := file_Run(fname, argptr);
2205  2409             // Notes : current program releases any allocated memory but
2206  2410             //       : retains the stack and global memory.
2207  2411             //       : If arglistptr is 0, no arguments are passed, else
2208  2412             //       : arglist points to an array, the first element being
2209  2413             //       : the number of elements in the array.
2210  2414             //       : func 'main' in the called program accepts
2211  2415             //       : the arguments, if any. THe arguments can only
2212  2416             //       : be passed by value, no pointers or references can be
2213  2417             //       : used as all memory is cleared before the file
2214  2418             //       : is loaded. Refer to file_Exec and file_LoadFunction
2215  2419             //       : for functions that can pass by reference.
2216  2420   
2217  2421             func file_Exec("fname.4xe", "arglistptr"), 1;
2218  2422             // Syntax: res := file_Exec("fname.4xe","arglistptr");
2219  2423             // Usage : res := file_Exec("fname.4xe","arglistptr");
2220  2424             // Notes : returns like a function, current program
2221  2425             //       : calling program is kept active and control returns to it.
2222  2426             //       : If arglistptr is 0, no arguments are passed, else
2223  2427             //       : arglist points to an array, the first element being
2224  2428             //       : the number of elements in the array.
2225  2429             //       : func 'main' in the called program accepts the arguments.
2226  2430             //       : This function is similar to file_LoadFunction(...), however,
2227  2431             //       : the function argument list is passed by pointer, and
2228  2432             //       : the memory consumed by the function is released as
2229  2433             //       : soon as the function completes.
2230  2434   
2231  2435             func file_LoadImageControl("fname1", "fname2", "mode"), 1;
2232  2436             // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
2233  2437             // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
2234  2438             // Notes : Reads a control file to create an image list.
2235  2439             //       : Returns NULL if function fails.
2236  2440             //       : Returns a handle (pointer to the memory allocation) to the
2237  2441             //       : image control list that has been created.
2238  2442             //       : "fname1" is the control list filename "*.dat"
2239  2443             //       : "fname2" is the image filename "*.gci"
2240  2444   
2241  2445             // Notes : This function Calculates the size of a chunk of memory required for
2242  2446             //       : a image list and populates it from the image control file ("*.dat")
2243  2447             //       : therefore, when imagelist is no longer required, you must de-allocate
2244  2448             //       : the image list memory by using eg:- mem_Free(hImagelist);
2245  2449             //       : to restore the heap.
2246  2450             //       :
2247  2451             //       : mode 0:- it is assumed that there is a graphics file with the
2248  2452             //       : file extension "fname2.gci". In this case, the images have been stored
2249  2453             //       : in a FAT16 file concurrently, and the offsets that ar derived from the
2250  2454             //       : "fname1.dat" file are saved in the image control so that the image control
2251  2455             //       : can open the file (*.gci) and us file_Seek to get to the position of the
2252  2456             //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
2253  2457             //       : mode 0 builds the image control quickly as it only scans the *.dat file
2254  2458             //       : for the file offsets and save them in the relevant entries in the image control.
2255  2459             //       : The penalty is that images take longer to find when displayed due to file_Seek
2256  2460             //       : overheads.
2257  2461             //
2258  2462             //       : mode 1:- it is assumed that there is a graphics file with the
2259  2463             //       : file extension "fname2.gci". In this case, the images have been stored
2260  2464             //       : in a FAT16 file concurrently, and the offset of the images are saved
2261  2465             //       : in the image control so that image file (*.gci) can be mapped to directly.
2262  2466             //       : The absolute cluster/sector is mapped so file seek does not need to be called
2263  2467             //       : internally. This means that there is no seek time penalty, however, the
2264  2468             //       : image list takes a lot longer to build, as all the seeking is done at control
2265  2469             //       : build time.
2266  2470   
2267  2471             //       : mode 2:- the graphics file with the is placed in a partitioned area
2268  2472             //       : In this case, the images have been stored in a in a known raw area of the FAT16
2269  2473             //       : disk, and the absolute address of the images are saved in the DAT file
2270  2474             //       : This is the fastest operation of the image control as there is no seeking
2271  2475             //       : or other disk activity taking place.
2272  2476   
2273  2477             func file_Mount(), 1;
2274  2478             // Syntax: r := file_Mount();
2275  2479             // Usage : r := file_Mount();
2276  2480             // Notes : Create a control block for FAT16 and mount the File System
2277  2481   
2278  2482             func file_Unmount(), 0;
2279  2483             // Syntax: file_Unmount();
2280  2484             // Usage : file_Unmount();
2281  2485             // Notes : release any control block and buffers for FAT16
2282  2486             //       : and unmount the File System
2283  2487   
2284  2488             func file_PlayWAV("fname1"), 1;
2285  2489             // Syntax: file_PlayWAV("fname1");
2286  2490             // Usage : file_PlayWAV("ding.wav");
2287  2491             // Notes : Play a wave file with filename "fname1"
2288  2492             //       : This function automatically grabs a chunk
2289  2493             //       : of memory for a file buffer, and a wave
2290  2494             //       : buffer. The minimum memory requirement is
2291  2495             //       : about 580 bytes for the disk io service and
2292  2496             //       : a minimum wave buffer size of 1024. The siz
2293  2497             //       : of the wave buffer allocation
2294  2498             //       : can be increased by the snd_BufSize function.
2295  2499             //       : The default size 1024 bytes.
2296  2500             //       : NB the memory is only required during the
2297  2501             //       : duration of play, and is automatically
2298  2502             //       : released while not in use.
2299  2503             //       : See the Sound Class services for other associated controls.
2300  2504             //       : If there are no errors, returns number of blocks to play (1 to 32767)
2301  2505             //       : If errors occured, the folling is returned
2302  2506             //       : -6   : cant play this rate
2303  2507             //       : -5  : no data chunk found in first rsector
2304  2508             //       : -4  : no format data
2305  2509             //       : -3  : no wave chunk signature
2306  2510             //       : -2  : bad wave file format
2307  2511             //       : -1  : file not found
2308  2512   
2309  2513   
2310  2514   
2311  2515             //------------------------------------------------------------------//
2312  2516             //        Sound Class Services
2313  2517             //------------------------------------------------------------------//
2314  2518   
2315  2519             func snd_Volume("var"), 0;
2316  2520             // Syntax: snd_Volume("var");
2317  2521             // Usage : snd_Volume(30);
2318  2522             // Notes : set sound playback volume.  Var must
2319  2523             //       : be in the range from 8 (min volume)
2320  2524             //       : to 127 (max volume). If var is less
2321  2525             //       : than 8 volume is set to 8, and if
2322  2526             //       : var > 127 it is set to 127.
2323  2527   
2324  2528             func snd_Pitch("pitch"), 1;
2325  2529             // func snd_Pitch("freq"), 1;
2326  2530             // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
2327  2531             // Notes : sets the samples playback rate to a different frequency
2328  2532             //       : The minimum value is 4khz
2329  2533             //       : Setting the pitch to zero restores the original sample rate
2330  2534             //       : Return value is the samples original sample rate.
2331  2535   
2332  2536             func snd_BufSize("var"), 0;
2333  2537             // Syntax: snd_BufSize("var");
2334  2538             // Usage : snd_BufSize(2);
2335  2539             // Notes : specify the a memory chunk size for the wavefile buffer.
2336  2540             //       : default size 1024 bytes.
2337  2541             //       : 0 = 1024 bytes (default)
2338  2542             //       : 1 = 2048 bytes
2339  2543             //       : 2 = 4096 bytes
2340  2544             //       : 3 = 8192 bytes
2341  2545   
2342  2546             func snd_Stop(), 0;
2343  2547             // Syntax: snd_Stop();
2344  2548             // Usage : snd_Stop();
2345  2549             // Notes : stop any sound that is playing, releasing
2346  2550             //       : buffers and closes any open wav file.
2347  2551   
2348  2552             func snd_Pause(), 0;
2349  2553             // Syntax: snd_Pause();
2350  2554             // Usage : snd_Pause();
2351  2555             // Notes : pauses any sound that is playing, does nothing
2352  2556             //       : until sound is resumed with snd_Continue().
2353  2557             //       : The sample cam be terminated with snd_Stop.
2354  2558             //       : buffers and closes any open wav file.
2355  2559   
2356  2560             func snd_Continue(), 0;
2357  2561             // Syntax: snd_Continue();
2358  2562             // Usage : snd_Continue();
2359  2563             // Notes : resume any sound that is paused by snd_Pause.
2360  2564   
2361  2565             func snd_Playing(), 1;
2362  2566             // Syntax: snd_Playing();
2363  2567             // Usage : r := snd_Playing();
2364  2568             // Notes : returns 0 if sound has finished playing,
2365  2569             //       : else return number of 512 byte blocks to go.
2366  2570   
2367  2571   
2368  2572   
2369  2573             //------------------------------------------------------------------//
2370  2574             //        String Class Services
2371  2575             //------------------------------------------------------------------//
2372  2576   
2373  2577             func str_Ptr("&var"), 1;
2374  2578             // Syntax: str_Ptr(&var);
2375  2579             // Usage : p := str_Ptr(&var);
2376  2580             // Notes : return a byte pointer to a word region
2377  2581   
2378  2582             func str_GetD("&ptr", "&var"), 1;
2379  2583             // Syntax: str_GetD(&ptr, &var);
2380  2584             // Usage : ok := str_GetD(&ptr, &var);
2381  2585             // Notes : convert number in a string to DWORD ( myvar[2] )
2382  2586             //       : returns true if function succeeds, advancing ptr
2383  2587   
2384  2588             func str_GetW("&ptr", "&var"), 1;
2385  2589             // Syntax: str_GetW(&ptr, &var);
2386  2590             // Usage : ok := str_GetW(&ptr, &var);
2387  2591             // Notes : convert number in a string to WORD ( myvar )
2388  2592             //       : returns true if function succeeds, advancing ptr
2389  2593   
2390  2594             func str_GetHexW("&ptr", "&var"), 1;
2391  2595             // Syntax: str_GetHexW(&ptr, &var);
2392  2596             // Usage : ok := str_GetHexW(&ptr, &var);
2393  2597             // Notes : convert HEX number in a string to WORD ( myvar )
2394  2598             //       : returns true if function succeeds, advancing ptr
2395  2599   
2396  2600             func str_GetC("&ptr", "&var"), 1;
2397  2601             // Syntax: str_GetC(&ptr, &var);
2398  2602             // Usage : ok := str_GetC(&ptr, &var);
2399  2603             // Notes : get a valid ascii char in a string to WORD ( myvar )
2400  2604             //       : returns true if function succeeds, advancing ptr
2401  2605   
2402  2606             func str_GetByte("ptr"), 1;
2403  2607             // Syntax: str_GetByte(ptr);
2404  2608             // Usage : myvar := str_GetByte(ptr);
2405  2609             // Notes : get a byte to myvar
2406  2610             //       : returns value
2407  2611   
2408  2612             func str_GetWord("ptr"), 1;
2409  2613             // Syntax: GetWord(ptr);
2410  2614             // Usage : GetWord(ptr);
2411  2615             // Notes : get a word to myvar
2412  2616             //       : returns value
2413  2617   
2414  2618             func str_PutByte("ptr","val"), 0;
2415  2619             // Syntax: str_PutByte(ptr);
2416  2620             // Usage : myvar := str_PutByte(ptr);
2417  2621             // Notes : put a byte at ptr
2418  2622             //       : returns value
2419  2623   
2420  2624             func str_PutWord("ptr","val"), 0;
2421  2625             // Syntax: str_PutWord("ptr","val");
2422  2626             // Usage : str_PutWord(p,100);
2423  2627             // Notes : put word 100 at current pointer location
2424  2628             //       : returns value
2425  2629   
2426  2630             func str_Match("&ptr", "*str"), 1;
2427  2631             // Syntax: str_Match(&ptr, *str);
2428  2632             // Usage : r := str_Match(&p, "hello");
2429  2633             // Notes : Case sensitive match
2430  2634             //       : returns true if function succeded, andvancing pointer to position past
2431  2635             //       : the matched item. Note that any whitespace characters are skipped
2432  2636             //       : in the source string prior to the test.
2433  2637   
2434  2638             func str_MatchI("&ptr", "*str"), 1;
2435  2639             // Syntax: str_MatchI(&ptr, *str);
2436  2640             // Usage : r := str_MatchI(&p, "hello");
2437  2641             // Notes : Case insensitive match
2438  2642             //       : returns true if function succeded, andvancing pointer to position past
2439  2643             //       : the matched item. Note that any whitespace characters are skipped
2440  2644             //       : in the source string prior to the test.
2441  2645   
2442  2646             func str_Find("&ptr", "*str"), 1;
2443  2647             // Syntax: str_Find(&ptr, *str);
2444  2648             // Usage : n := str_Find(&p, "hello");
2445  2649             // Notes : given the address of a pointer to a source string as the
2446  2650             //       : first argument, and a pointer to a test string as the second
2447  2651             //       : argument, attempt to find the position of the matching string
2448  2652             //       : in the source string. The test is performed with case sensitivity.
2449  2653             //       : return 0 if not found, else returns the address of the first
2450  2654             //       : character of the match. NB:- The source pointer is not altered.
2451  2655   
2452  2656             func str_FindI("&ptr", "*str"), 1;
2453  2657             // Syntax: str_Find(&ptr, *str);
2454  2658             // Usage : n := str_Find(&p, "hello");
2455  2659             // Notes : given the address of a pointer to a source string as the
2456  2660             //       : first argument, and a pointer to a test string as the second
2457  2661             //       : argument, attempt to find the position of the matching string
2458  2662             //       : in the source string. The test is performed with no case
2459  2663             //       : sensitivity, eg upper and lower case chars are accepted.
2460  2664             //       : return 0 if not found, else returns the address of the first
2461  2665             //       : character of the match. NB:- The source pointer is not altered.
2462  2666   
2463  2667             func str_Length("ptr"), 1;
2464  2668             // Syntax: str_Length(ptr);
2465  2669             // Usage : len := str_Ptr(mystring);
2466  2670             // Notes : return the length of a byte aligned string excluding terminator
2467  2671   
2468  2672             func str_Printf("&ptr", "*format"), 1;
2469  2673             // Syntax: str_Printf("&ptr", "*format");
2470  2674             // Usage : r := str_Printf(&p, "hello");
2471  2675             // Notes : refer to documentation
2472  2676             //       :
2473  2677   
2474  2678             func str_Cat("dest","src"), 1;
2475  2679             // Syntax: str_Append("&dest","&src");
2476  2680             // Usage : str_Append(&buf,"Hello");
2477  2681             // Notes : Appends a copy of the source string to the destination string.
2478  2682             //       : The terminating null character in destination is overwritten by
2479  2683             //       : the first character of source, and a new null-character is appended
2480  2684             //       : at the end of the new string formed by the concatenation of both in destination.
2481  2685             //       : returns destination.
2482  2686   
2483  2687             func str_CatN("dest","src","count"), 1;
2484  2688             // Syntax: str_Append("&dest","&src","count");
2485  2689             // Usage : str_Append(&buf,"Monday",3);
2486  2690             // Notes : Appends a copy of the source string to the destination string.
2487  2691             //       : The number of characters copied is limited by "count".
2488  2692             //       : The terminating null character in destination is overwritten by
2489  2693             //       : the first character of source, and a new null-character is appended
2490  2694             //       : at the end of the new string formed by the concatenation of both in destination.
2491  2695             //       : returns destination.
2492  2696   
2493  2697   
2494  2698             func sys_StoreTouchCalibration(), 1;
2495  2699             // Syntax: sys_StoreTouchCalibration();
2496  2700             // Usage : r := sys_StoreTouchCalibration();
2497  2701             // Notes : Store the touch calibration values in non-volatile memory.
2498  2702             //       : Returns true if the values have been accepted and stored,
2499  2703             //       : else returns false if write could not be performed, or
2500  2704             //       : touch calibration values are improbable.
2501  2705             //       : The values that are stored are obtained from:-
2502  2706             //     : TOUCH_XMINCAL             78  // touch calibration value
2503  2707             //     : TOUCH_YMINCAL             79  // touch calibration value
2504  2708             //       : TOUCH_XMAXCAL             80  // touch calibration value
2505  2709             //       : TOUCH_YMAXCAL             81  // touch calibration value
2506  2710             //       : refer to the 4DGL example touchCalibrate.4DG for further information.
2507  2711             //       : This function is not supported on uVGA, Capicitive touch
2508  2712             //       : and 4.3" resistive touch modules.
2509  2713   
2510  2714   
2511  2715             func unicode_page("charbeg","charend","charoffset"), 1;
2512  2716             // Syntax: unicode_page("charbeg","charend","charoffset");
2513  2717             // Usage : eg:  F_Traditional_0x20_0xFF
2514  2718             // Notes : After selecting a unicode image control with txt_FontID,
2515  2719             //       : this function is called to set the required font within the
2516  2720             //       : unicode set. The file "Unicode.inc" contains wrappers for
2517  2721             //       : this function, and it is not normally called directly.
2518  2722             //       : Returns count of characters in the set.
2519  2723             //       : Refer to "Unicode.inc" for further information.
2520  2724   
2521  2725   
2522  2726             func EVE_SP(), 1;
2523  2727             // Syntax: EVE_SP();
2524  2728             // Usage : eg:  print(EVE_SP());
2525  2729             // Notes : Used for debugging to assess the current stack level,
2526  2730             //       : mainly for checking stack leaks
2527  2731   
2528  2732             func EVE_SSIZE(), 1;
2529  2733             // Syntax: EVE_SSIZE();
2530  2734             // Usage : eg:  print(EVE_SSIZE());
2531  2735             // Notes : Used to get the stack size,
2532  2736             //       : mainly for debugging purposes
2533  2737   
2534  2738   
2535  2739             // uVGAII extended functions
2536  2740             func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
2537  2741             // Syntax: disp_Sync(line);
2538  2742             // Usage : disp_Sync(480);
2539  2743             // Notes : Waits till the hardware gets to a certain line.
2540  2744             //       : Allows the program to synchronise writing to the hardware for flicker free operation.
2541  2745             //       : Some experimentation may be needed to find an optimum line for disp_Sync
2542  2746             //       : depending on the graphics operation. The higher the value, the slower
2543  2747             //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
2544  2748             //       : within the vertical retrace period) where it will just 'hang up' stopping the
2545  2749             //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
2546  2750             //       : be slowest (as its actually right at the end of the blanking period) and 508
2547  2751             //       : will cause a hangup situation as it is above the highes scanline value.
2548  2752             //       : Currently, this function is only supported on displays with SSD1963 driver.
2549  2753   
2550  2754   
2551  2755             // New functions added to PmmC v2.8
2552  2756             //================================================================
2553  2757             func CY(), 1;
2554  2758             // Syntax: CY();
2555  2759             // Usage : myvar := 0xFFF8 + 9;                 // result = 1
2556  2760             //       : print(myvar," "CY(),"\n");           // carry = 1
2557  2761             // Notes : This function returns the carry status of an
2558  2762             // unsigned overflow from any 16 or 32bit additions or sutractions.
2559  2763             //================================================================
2560  2764   
2561  2765   
2562  2766             //================================================================
2563  2767             func str_ByteMove("src", "dest", "count"), 1;
2564  2768             // func str_ByteMove("src", "dest", "count"), 1;
2565  2769             // Syntax   : str_ByteMove(src, dest, bytecount);
2566  2770             // Input    : STR *source points to byte aligned source.
2567  2771             //          : STR *dest   points to byte aligned destination.
2568  2772             //          : VAR count   number of bytes to transfer.
2569  2773             // Usage    : nextpos := str_ByteMove(s, d, 100);
2570  2774             // Notes    : copy bytes from "src" to "dest", stopping only
2571  2775             //          : when "count" is exhausted.
2572  2776             //          : No terminator is appended, it is purely a
2573  2777             //          : byte copy, and any zeroes encountered will
2574  2778             //          : also be copied.
2575  2779             // Returns  : returns a pointer to the end of the destination
2576  2780             //          : (which is "dest" + "count")
2577  2781             //================================================================
2578  2782   
2579  2783   
2580  2784             //================================================================
2581  2785             func str_Copy("dest", "src"), 1;
2582  2786             // Syntax   : str_Copy(dest, src);
2583  2787             // Input    : STR *dest   points to byte aligned destination.
2584  2788             //          : STR *source points to byte aligned source.
2585  2789             // Usage    : nextplace := str_Copy(d, s);
2586  2790             // Notes    : copy a string from "src" to "dest", stopping only
2587  2791             //          : when the end of source string "src" is encountered
2588  2792             //          : (0x00 terminator).
2589  2793             //          : The terminator is always appended, even if "src" is
2590  2794             //          : an empty string.
2591  2795             // Returns  : returns a pointer to the 0x00 string terminator at
2592  2796             //          : end of "dest" (which is "dest" + str_Length(src); )
2593  2797             //================================================================
2594  2798   
2595  2799             //================================================================
2596  2800             func str_CopyN("dest", "src", "count"), 1;
2597  2801             // Syntax   : str_CopyN(dest, src, bytecount);
2598  2802             // Input    : STR *dest   points to byte aligned destination.
2599  2803             //          : STR *source points to byte aligned source.
2600  2804             //          : VAR count   max number of chars to copy.
2601  2805             // Usage    : nextplace := str_CopyN(d, s, 100);
2602  2806             // Notes    : copy a string from "src" to "dest", stopping only
2603  2807             //          : when "count" is exhausted, or end of source
2604  2808             //          : string "str" is encountered (0x00 string terminator).
2605  2809             //          : The terminator is always appended, even if
2606  2810             //          : "count" is zero, or "src" is a null string.
2607  2811             // Returns  : returns a pointer to the 0x00 string terminator
2608  2812             //          : (which is "dest" + whatever was copied)
2609  2813             //================================================================
2610  2814   
2611  2815             //================================================================
2612  2816             func umul_1616("&res32", "val1", "val2"), 1;
2613  2817             // Syntax   : umul_1616(&res32, varA, varB);
2614  2818             // Input    : DWORD *result   points to 32bit result register.
2615  2819             //          : VAR   val1  16bit register or constant
2616  2820             //          : VAR   val2  16bit register or constant
2617  2821             // Usage    : var res32[2];
2618  2822             //          : umul_1616(&res32, myvar, 50000);
2619  2823             // Notes    : performs an unsigned multiply of 2 x 16bit values
2620  2824             //          : placing the 32bit result in a 2 word array.
2621  2825             // Returns  : the pointer to the 32bit result.
2622  2826             //          : carry and overflow are not affected.
2623  2827             //================================================================
2624  2828   
2625  2829             //================================================================
2626  2830             func uadd_3232("&res32", "&val1", "&val2"), 1;
2627  2831             // Syntax   : cmp_3232(&res32, &varA, &varB);
2628  2832             // Input    : DWORD *res32 points to optional result (or zero for compare)
2629  2833             //          : DWORD *val1 points to 32bit augend
2630  2834             //          : DWORD *val2 points to 32bit addend
2631  2835             // Usage    : var res32[2];
2632  2836             //          : res := cmp_3232(res32, val1, val2);
2633  2837             // Notes    : performs an unsigned addition of 2 x 32bit values
2634  2838             //          : placing the 32bit result in a 2 word array.
2635  2839             // Returns  : returns 1 on 32bit unsigned overflow (carry).
2636  2840             //          ; carry flag is also set on 32bit unsigned overflow
2637  2841             //          ; and can be read with the CY() function.
2638  2842             //================================================================
2639  2843   
2640  2844             //================================================================
2641  2845             func usub_3232("&res32", "&val1", "&val2"), 1;
2642  2846             // Syntax   : cmp_3232(&res32, &varA, &varB);
2643  2847             // Input    : DWORD *res32 points to optional result (or zero for compare)
2644  2848             //          : DWORD *val1 points to first 32bit minuend
2645  2849             //          : DWORD *val2 points to 32bit subtrahend
2646  2850             // Usage    : var res32[2];
2647  2851             //          : res := cmp_3232(res32, val1, val2);
2648  2852             // Notes    : performs an unsigned subtraction of 2 x 32bit values
2649  2853             //          : placing the 32bit result in a 2 word array.
2650  2854             // Returns  : returns 1 on 32bit unsigned overflow (borrow).
2651  2855             //          ; carry flag is also set on 32bit unsigned underflow
2652  2856             //          ; and can be read with the CY() function.
2653  2857             //================================================================
2654  2858   
2655  2859             //================================================================
2656  2860             func ucmp_3232("&val1", "&val2"), 1;
2657  2861             // Syntax   : cmp_3232(&varA, &varB);
2658  2862             // Input    : DWORD *val1 points to 32bit minuend
2659  2863             //          : DWORD *val2 points to 32bit sutrahend
2660  2864             // Usage    : res := cmp_3232(val1, val2);
2661  2865             // Notes    : performs an unsigned comparison of 2 x 32bit values.
2662  2866             //          : The result of the subtraction is returned.
2663  2867             // Returns  : 0  if equal
2664  2868             //          : 1  if val1 > val2
2665  2869             //          : -1 if val1 < val2
2666  2870             //          : This function does not affect the carry flag.
2667  2871             //================================================================
2668  2872   
2669  2873             //------------------------------------------------------------------//
2670  2874             // CONSTANTS
2671  2875             //------------------------------------------------------------------//
2672  2876   
2673  2877             // generic constants
2674  2878             #CONST
2675  2887             #END
2676  2888   
2677  2889             //------------------------------------------------------------------------------
2678  2890             // Pin related constants
2679  2891             //------------------------------------------------------------------------------
2680  2892             #CONST
2681  2910             #END
2682  2911   
2683  2912             //------------------------------------------------------------------------------
2684  2913             //gfx_Set() related constants
2685  2914             //------------------------------------------------------------------------------
2686  2915             #CONST
2687  2932             #END
2688  2933   
2689  2934   
2690  2935             //gfx_Get() related constants
2691  2936             #CONST
2692  2945             #END
2693  2946   
2694  2947   
2695  2948   
2696  2949   
2697  2950             #CONST
2698  2963             #END
2699  2964   
2700  2965   
2701  2966             #CONST
2702  2989             #END
2703  2990   
2704  2991             //------------------------------------------------------------------------------
2705  2992             //txt_Set() related constants
2706  2993             //------------------------------------------------------------------------------
2707  2994             #CONST
2708  3013             #END
2709  3014   
2710  3015   
2711  3016   
2712  3017             //------------------------------------------------------------------------------
2713  3018             //txt_Set() related arguments
2714  3019             // NB:- FONT4 must be inherited if required,
2715  3020             // eg #inherit "FONT4.fnt"
2716  3021             //------------------------------------------------------------------------------
2717  3022             #CONST
2718  3034             #END
2719  3035   
2720  3036   
2721  3037   
2722  3038             //touch_Set() related constants
2723  3039             #CONST
2724  3043             #END
2725  3044   
2726  3045             //touch_Get() related constants
2727  3046             #CONST
2728  3054             #END
2729  3055   
2730  3056             // image control offset related constants
2731  3057             #CONST
2732  3064             #END
2733  3065   
2734  3066             // image attribute flags
2735  3067             // for img_SetAttributes(...) and img_ClearAttributes(...)
2736  3068             #CONST
2737  3082             #END
2738  3083   
2739  3084   
2740  3085             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2741  3085             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2742  3086   
2743  3087             // image control entry offsets
2744  3088             #CONST
2745  3103             #END
2746  3104   
2747  3105             #CONST
2748  3123             #END
2749  3124   
2750  3125   
2751  3126   
2752  3127   
2753  3128             #CONST
2754  3148             #END
2755  3149   
2756  3150   
2757  3151   
2758  3152             // timer control  related constants
2759  3153             #CONST
2760  3162             #END
2761  3163   
2762  3164             // I2C timing related constants
2763  3165             #CONST
2764  3169             #END
2765  3170   
2766  3171   
2767  3172             // spi_Init(...)  mode arguments
2768  3173             #CONST
2769  3183             #END
2770  3184   
2771  3185             //------------------------------------------------------------------------------
2772  3186             // system WORD variables accesible with peekW and pokeW or pointer access
2773  3187             // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
2774  3188             // can also be accessed with peekW and pokeW
2775  3189             //------------------------------------------------------------------------------
2776  3190   
2777  3191             #CONST
2778  3283             #END
2779  3284   
2780  3285             //------------------------------------------------------------------------------
2781  3286             // FILEIO Error Code Constants
2782  3287             //------------------------------------------------------------------------------
2783  3288             #CONST
2784  3313             #END
2785  3314   
2786  3315             //==================================================================================================
2787  3316   
2788  3317   
2789  3318   
2790  0013                 #ENDIF
2791  0014   
2792  0015   
2793  0016                 #CONST
2794  0072                 #END
2795  0073   
2796  0074   
2797  0075             //===========================================================================================
2798  0076   
2799  0077   
2800  0002   
2801  0003              /* INHERIT */
file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\4DGL_16bitColours.fnc

2802  0004             #inherit "4DGL_16bitColours.fnc"
2803  0004             #inherit "4DGL_16bitColours.fnc"
2804  0004             */
2805  0005   
2806  0006   
2807  0007   
2808  0008             #CONST
2809  0149             #END
2810  0150   
file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\FONT4.fnt

2811  0005             #inherit "FONT4.fnt"
2812  0005             #inherit "FONT4.fnt"
2813  0001   
2814  0002             // FONT4 must be included for backward compatibility
2815  0003   
2816  0108   0007 #END
2817  00072818  00082819  00092820  000A2821  000B2822  000C2823  000D2824  000E2825  000F2826  00102827  00112828  00122829  00132830  00142831  00152832  00162833  00172834  00182835  00192836  001A2837  001B2838  001C2839  001D2840  001E2841  001F2842  00202843  00212844  00222845  00232846  00242847  00252848  00262849  00272850  00282851  00292852  002A2853  002B2854  002C2855  002D2856  002E2857  002F2858  00302859  00312860  00322861  00332862  00342863  00352864  00362865  00372866  00382867  00392868  003A2869  003B2870  003C2871  003D2872  003E2873  003F2874  00402875  00412876  00422877  00432878  00442879  00452880  00462881  00472882  00482883  00492884  004A2885  004B2886  004C2887  004D2888  004E2889  004F2890  00502891  00512892  00522893  00532894  00542895  00552896  00562897  00572898  00582899  00592900  005A2901  005B2902  005C2903  005D2904  005E2905  005F2906  00602907  00612908  00622909  00632910  00642911  00652912  00662913  00672914  00682915  00692916  006A2917  006B2918  006C2919  006D2920  006E2921  006F2922  00702923  00712924  00722925  00732926  00742927  00752928  00762929  00772930  00782931  00792932  007A2933  007B2934  007C2935  007D2936  007E2937  007F2938  00802939  00812940  00822941  00832942  00842943  00852944  00862945  00872946  00882947  00892948  008A2949  008B2950  008C2951  008D2952  008E2953  008F2954  00902955  00912956  00922957  00932958  00942959  00952960  00962961  00972962  00982963  00992964  009A2965  009B2966  009C2967  009D2968  009E2969  009F2970  00A02971  00A12972  00A22973  00A32974  00A42975  00A52976  00A62977  00A72978  00A82979  00A92980  00AA2981  00AB2982  00AC2983  00AD2984  00AE2985  00AF2986  00B02987  00B12988  00B22989  00B32990  00B42991  00B52992  00B62993  00B72994  00B82995  00B92996  00BA2997  00BB2998  00BC2999  00BD3000  00BE3001  00BF3002  00C03003  00C13004  00C23005  00C33006  00C43007  00C53008  00C63009  00C73010  00C83011  00C93012  00CA3013  00CB3014  00CC3015  00CD3016  00CE3017  00CF3018  00D03019  00D13020  00D23021  00D33022  00D43023  00D53024  00D63025  00D73026  00D83027  00D93028  00DA3029  00DB3030  00DC3031  00DD3032  00DE3033  00DF3034  00E03035  00E13036  00E23037  00E33038  00E43039  00E53040  00E63041  00E73042  00E83043  00E93044  00EA3045  00EB3046  00EC3047  00ED3048  00EE3049  00EF3050  00F03051  00F13052  00F23053  00F33054  00F43055  00F53056  00F63057  00F73058  00F83059  00F93060  00FA3061  00FB3062  00FC3063  00FD3064  00FE3065  00FF3066  01003067  01013068  01023069  01033070  01043071  01053072  01063073  01073074  01083075  01093076  010A3077  010B3078  010C3079  010D3080  010E3081  010F3082  01103083  01113084  01123085  01133086  01143087  01153088  01163089  01173090  01183091  01193092  011A3093  011B3094  011C3095  011D3096  011E3097  011F3098  01203099  01213100  01223101  01233102  01243103  01253104  01263105  01273106  01283107  01293108  012A3109  012B3110  012C3111  012D3112  012E3113  012F3114  01303115  01313116  01323117  01333118  01343119  01353120  01363121  01373122  01383123  01393124  013A3125  013B3126  013C3127  013D3128  013E3129  013F3130  01403131  01413132  01423133  01433134  01443135  01453136  01463137  01473138  01483139  01493140  014A3141  014B3142  014C3143  014D3144  014E3145  014F3146  01503147  01513148  01523149  01533150  01543151  01553152  01563153  01573154  01583155  01593156  015A3157  015B3158  015C3159  015D3160  015E3161  015F3162  01603163  01613164  01623165  01633166  01643167  01653168  01663169  01673170  01683171  01693172  016A3173  016B3174  016C3175  016D3176  016E3177  016F3178  01703179  01713180  01723181  01733182  01743183  01753184  01763185  01773186  01783187  01793188  017A3189  017B3190  017C3191  017D3192  017E3193  017F3194  01803195  01813196  01823197  01833198  01843199  01853200  01863201  01873202  01883203  01893204  018A3205  018B3206  018C3207  018D3208  018E3209  018F3210  01903211  01913212  01923213  01933214  01943215  01953216  01963217  01973218  01983219  01993220  019A3221  019B3222  019C3223  019D3224  019E3225  019F3226  01A03227  01A13228  01A23229  01A33230  01A43231  01A53232  01A63233  01A73234  01A83235  01A93236  01AA3237  01AB3238  01AC3239  01AD3240  01AE3241  01AF3242  01B03243  01B13244  01B23245  01B33246  01B43247  01B53248  01B63249  01B73250  01B83251  01B93252  01BA3253  01BB3254  01BC3255  01BD3256  01BE3257  01BF3258  01C03259  01C13260  01C23261  01C33262  01C43263  01C53264  01C63265  01C73266  01C83267  01C93268  01CA3269  01CB3270  01CC3271  01CD3272  01CE3273  01CF3274  01D03275  01D13276  01D23277  01D33278  01D43279  01D53280  01D63281  01D73282  01D83283  01D93284  01DA3285  01DB3286  01DC3287  01DD3288  01DE3289  01DF3290  01E03291  01E13292  01E23293  01E33294  01E43295  01E53296  01E63297  01E73298  01E83299  01E93300  01EA3301  01EB3302  01EC3303  01ED3304  01EE3305  01EF3306  01F03307  01F13308  01F23309  01F33310  01F43311  01F53312  01F63313  01F73314  01F83315  01F93316  01FA3317  01FB3318  01FC3319  01FD3320  01FE3321  01FF3322  02003323  02013324  02023325  02033326  02043327  02053328  02063329  02073330  02083331  02093332  020A3333  020B3334  020C3335  020D3336  020E3337  020F3338  02103339  02113340  02123341  02133342  02143343  02153344  02163345  02173346  02183347  02193348  021A3349  021B3350  021C3351  021D3352  021E3353  021F3354  02203355  02213356  02223357  02233358  02243359  02253360  02263361  02273362  02283363  02293364  022A3365  022B3366  022C3367  022D3368  022E3369  022F3370  02303371  02313372  02323373  02333374  02343375  02353376  02363377  02373378  02383379  02393380  023A3381  023B3382  023C3383  023D3384  023E3385  023F3386  02403387  02413388  02423389  02433390  02443391  02453392  02463393  02473394  02483395  02493396  024A3397  024B3398  024C3399  024D3400  024E3401  024F3402  02503403  02513404  02523405  02533406  02543407  02553408  02563409  02573410  02583411  02593412  025A3413  025B3414  025C3415  025D3416  025E3417  025F3418  02603419  02613420  02623421  02633422  02643423  02653424  02663425  02673426  02683427  02693428  026A3429  026B3430  026C3431  026D3432  026E3433  026F3434  02703435  02713436  02723437  02733438  02743439  02753440  02763441  02773442  02783443  02793444  027A3445  027B3446  027C3447  027D3448  027E3449  027F3450  02803451  02813452  02823453  02833454  02843455  02853456  02863457  02873458  02883459  02893460  028A3461  028B3462  028C3463  028D3464  028E3465  028F3466  02903467  02913468  02923469  02933470  02943471  02953472  02963473  02973474  02983475  02993476  029A3477  029B3478  029C3479  029D3480  029E3481  029F3482  02A03483  02A13484  02A23485  02A33486  02A43487  02A53488  02A63489  02A73490  02A83491  02A93492  02AA3493  02AB3494  02AC3495  02AD3496  02AE3497  02AF3498  02B03499  02B13500  02B23501  02B33502  02B43503  02B53504  02B63505  02B73506  02B83507  02B93508  02BA3509  02BB3510  02BC3511  02BD3512  02BE3513  02BF3514  02C03515  02C13516  02C23517  02C33518  02C43519  02C53520  02C63521  02C73522  02C83523  02C93524  02CA3525  02CB3526  02CC3527  02CD3528  02CE3529  02CF3530  02D03531  02D13532  02D23533  02D33534  02D43535  02D53536  02D63537  02D73538  02D83539  02D93540  02DA3541  02DB3542  02DC3543  02DD3544  02DE3545  02DF3546  02E03547  02E13548  02E23549  02E33550  02E43551  02E53552  02E63553  02E73554  02E83555  02E93556  02EA3557  02EB3558  02EC3559  02ED3560  02EE3561  02EF3562  02F03563  02F13564  02F23565  02F33566  02F43567  02F53568  02F63569  02F73570  02F83571  02F93572  02FA3573  02FB3574  02FC3575  02FD3576  02FE3577  02FF3578  03003579  03013580  03023581  03033582  03043583  03053584  03063585  03073586  03083587  03093588  030A3589  030B3590  030C3591  030D3592  030E3593  030F3594  03103595  03113596  03123597  03133598  03143599  03153600  03163601  03173602  03183603  03193604  031A3605  031B3606  031C3607  031D3608  031E3609  031F3610  03203611  03213612  03223613  03233614  03243615  03253616  03263617  03273618  03283619  03293620  032A3621  032B3622  032C3623  032D3624  032E3625  032F3626  03303627  03313628  03323629  03333630  03343631  03353632  03363633  03373634  03383635  03393636  033A3637  033B3638  033C3639  033D3640  033E3641  033F3642  03403643  03413644  03423645  03433646  03443647  03453648  03463649  03473650  03483651  03493652  034A3653  034B3654  034C3655  034D3656  034E3657  034F3658  03503659  03513660  03523661  03533662  03543663  03553664  03563665  03573666  03583667  03593668  035A3669  035B3670  035C3671  035D3672  035E3673  035F3674  03603675  03613676  03623677  03633678  03643679  03653680  03663681  03673682  03683683  03693684  036A3685  036B3686  036C3687  036D3688  036E3689  036F3690  03703691  03713692  03723693  03733694  03743695  03753696  03763697  03773698  03783699  03793700  037A3701  037B3702  037C3703  037D3704  037E3705  037F3706  03803707  03813708  03823709  03833710  03843711  03853712  03863713  03873714  03883715  03893716  038A3717  038B3718  038C3719  038D3720  038E3721  038F3722  03903723  03913724  03923725  03933726  03943727  03953728  03963729  03973730  03983731  03993732  039A3733  039B3734  039C3735  039D3736  039E3737  039F3738  03A03739  03A13740  03A23741  03A33742  03A43743  03A53744  03A63745  03A73746  03A83747  03A93748  03AA3749  03AB3750  03AC3751  03AD3752  03AE3753  03AF3754  03B03755  03B13756  03B23757  03B33758  03B43759  03B53760  03B63761  03B73762  03B83763  03B93764  03BA3765  03BB3766  03BC3767  03BD3768  03BE3769  03BF3770  03C03771  03C13772  03C23773  03C33774  03C43775  03C53776  03C63777  03C73778  03C83779  03C93780  03CA3781  03CB3782  03CC3783  03CD3784  03CE3785  03CF3786  03D03787  03D13788  03D23789  03D33790  03D43791  03D53792  03D63793  03D73794  03D83795  03D93796  03DA3797  03DB3798  03DC3799  03DD3800  03DE3801  03DF3802  03E03803  03E13804  03E23805  03E33806  03E43807  03E53808  03E63809  03E73810  03E83811  03E93812  03EA3813  03EB3814  03EC3815  03ED3816  03EE3817  03EF3818  03F03819  03F13820  03F23821  03F33822  03F43823  03F53824  03F63825  03F73826  03F83827  03F93828  03FA3829  03FB3830  03FC3831  03FD3832  03FE3833  03FF3834  04003835  04013836  04023837  04033838  04043839  04053840  04063841  04073842  04083843  04093844  040A3845  040B3846  040C3847  040D3848  040E3849  040F3850  04103851  04113852  04123853  04133854  04143855  04153856  04163857  04173858  04183859  04193860  041A3861  041B3862  041C3863  041D3864  041E3865  041F3866  04203867  04213868  04223869  04233870  04243871  04253872  04263873  04273874  04283875  04293876  042A3877  042B3878  042C3879  042D3880  042E3881  042F3882  04303883  04313884  04323885  04333886  04343887  04353888  04363889  04373890  04383891  04393892  043A3893  043B3894  043C3895  043D3896  043E3897  043F3898  04403899  04413900  04423901  04433902  04443903  04453904  04463905  04473906  04483907  04493908  044A3909  044B3910  044C3911  044D3912  044E3913  044F3914  04503915  04513916  04523917  04533918  04543919  04553920  04563921  04573922  04583923  04593924  045A3925  045B3926  045C3927  045D3928  045E3929  045F3930  04603931  04613932  04623933  04633934  04643935  04653936  04663937  04673938  04683939  04693940  046A3941  046B3942  046C3943  046D3944  046E3945  046F3946  04703947  04713948  04723949  04733950  04743951  04753952  04763953  04773954  04783955  04793956  047A3957  047B3958  047C3959  047D3960  047E3961  047F3962  04803963  04813964  04823965  04833966  04843967  04853968  04863969  04873970  04883971  04893972  048A3973  048B3974  048C3975  048D3976  048E3977  048F3978  04903979  04913980  04923981  04933982  04943983  04953984  04963985  04973986  04983987  04993988  049A3989  049B3990  049C3991  049D3992  049E3993  049F3994  04A03995  04A13996  04A23997  04A33998  04A43999  04A54000  04A64001  04A74002  04A84003  04A94004  04AA4005  04AB4006  04AC4007  04AD4008  04AE4009  04AF4010  04B04011  04B14012  04B24013  04B34014  04B44015  04B54016  04B64017  04B74018  04B84019  04B94020  04BA4021  04BB4022  04BC4023  04BD4024  04BE4025  04BF4026  04C04027  04C14028  04C24029  04C34030  04C44031  04C54032  04C64033  04C74034  04C84035  04C94036  04CA4037  04CB4038  04CC4039  04CD4040  04CE4041  04CF4042  04D04043  04D14044  04D24045  04D34046  04D44047  04D54048  04D64049  04D74050  04D84051  04D94052  04DA4053  04DB4054  04DC4055  04DD4056  04DE4057  04DF4058  04E04059  04E14060  04E24061  04E34062  04E44063  04E54064  04E64065  04E74066  04E84067  04E94068  04EA4069  04EB4070  04EC4071  04ED4072  04EE4073  04EF4074  04F04075  04F14076  04F24077  04F34078  04F44079  04F54080  04F64081  04F74082  04F84083  04F94084  04FA4085  04FB4086  04FC4087  04FD4088  04FE4089  04FF4090  05004091  05014092  05024093  05034094  05044095  05054096  05064097  05074098  05084099  05094100  050A4101  050B4102  050C4103  050D4104  050E4105  050F4106  05104107  05114108  05124109  05134110  05144111  05154112  05164113  05174114  05184115  05194116  051A4117  051B4118  051C4119  051D4120  051E4121  051F4122  05204123  05214124  05224125  05234126  05244127  05254128  05264129  05274130  05284131  05294132  052A4133  052B4134  052C4135  052D4136  052E4137  052F4138  05304139  05314140  05324141  05334142  05344143  05354144  05364145  05374146  05384147  05394148  053A4149  053B4150  053C4151  053D4152  053E4153  053F4154  05404155  05414156  05424157  05434158  05444159  05454160  05464161  05474162  05484163  05494164  054A4165  054B4166  054C4167  054D4168  054E4169  054F4170  05504171  05514172  05524173  05534174  05544175  05554176  05564177  05574178  05584179  05594180  055A4181  055B4182  055C4183  055D4184  055E4185  055F4186  05604187  05614188  05624189  05634190  05644191  05654192  05664193  05674194  05684195  05694196  056A4197  056B4198  056C4199  056D4200  056E4201  056F4202  05704203  05714204  05724205  05734206  05744207  05754208  05764209  05774210  05784211  05794212  057A4213  057B4214  057C4215  057D4216  057E4217  057F4218  05804219  05814220  05824221  05834222  05844223  05854224  05864225  05874226  05884227  05894228  058A4229  058B4230  058C4231  058D4232  058E4233  058F4234  05904235  05914236  05924237  05934238  05944239  05954240  05964241  05974242  05984243  05994244  059A4245  059B4246  059C4247  059D4248  059E4249  059F4250  05A04251  05A14252  05A24253  05A34254  05A44255  05A54256  05A64257  05A74258  05A84259  05A94260  05AA4261  05AB4262  05AC4263  05AD4264  05AE4265  05AF4266  05B04267  05B14268  05B24269  05B34270  05B44271  05B54272  05B64273  05B74274  05B84275  05B94276  05BA4277  05BB4278  05BC4279  05BD4280  05BE4281  05BF4282  05C04283  05C14284  05C24285  05C34286  05C44287  05C54288  05C64289  05C74290  05C84291  05C94292  05CA4293  05CB4294  05CC4295  05CD4296  05CE4297  05CF4298  05D04299  05D14300  05D24301  05D34302  05D44303  05D54304  05D64305  05D74306  05D84307  05D94308  05DA4309  05DB4310  05DC4311  05DD4312  05DE4313  05DF4314  05E04315  05E14316  05E24317  05E34318  05E44319  05E54320  05E64321  05E74322  05E84323  05E94324  05EA4325  05EB4326  05EC4327  05ED4328  05EE4329  05EF4330  05F04331  05F14332  05F24333  05F34334  05F44335  05F54336  05F64337  05F74338  05F84339  05F94340  05FA4341  05FB4342  05FC4343  05FD4344  05FE4345  05FF4346  06004347  06014348  06024349  06034350  06044351  06054352  06064353  06074354  06084355  06094356  060A4357  060B4358  060C4359  060D4360  060E4361  060F4362  06104363  06114364  06124365  06134366  06144367  06154368  06164369  06174370  06184371  06194372  061A4373  061B4374  061C4375  061D4376  061E4377  061F4378  06204379  06214380  06224381  06234382  06244383  06254384  06264385  06274386  06284387  06294388  062A4389  062B4390  062C4391  062D4392  062E4393  062F4394  06304395  06314396  06324397  06334398  06344399  06354400  06364401  06374402  06384403  06394404  063A4405  063B4406  063C4407  063D4408  063E4409  063F4410  06404411  06414412  06424413  06434414  06444415  06454416  06464417  06474418  06484419  06494420  064A4421  064B4422  064C4423  064D4424  064E4425  064F4426  06504427  06514428  06524429  06534430  06544431  06554432  06564433  06574434  06584435  06594436  065A4437  065B4438  065C4439  065D4440  065E4441  065F4442  06604443  06614444  06624445  06634446  06644447  06654448  06664449  06674450  06684451  06694452  066A4453  066B4454  066C4455  066D4456  066E4457  066F4458  06704459  06714460  06724461  06734462  06744463  06754464  06764465  06774466  06784467  06794468  067A4469  067B4470  067C4471  067D4472  067E4473  067F4474  06804475  06814476  06824477  06834478  06844479  06854480  06864481  06874482  06884483  06894484  068A4485  068B4486  068C4487  068D4488  068E4489  068F4490  06904491  06914492  06924493  06934494  06944495  06954496  06964497  06974498  06984499  06994500  069A4501  069B4502  069C4503  069D4504  069E4505  069F4506  06A04507  06A14508  06A24509  06A34510  06A44511  06A54512  06A64513  06A74514  06A84515  06A94516  06AA4517  06AB4518  06AC4519  06AD4520  06AE4521  06AF4522  06B04523  06B14524  06B24525  06B34526  06B44527  06B54528  06B64529  06B74530  06B84531  06B94532  06BA4533  06BB4534  06BC4535  06BD4536  06BE4537  06BF4538  06C04539  06C14540  06C24541  06C34542  06C44543  06C54544  06C64545  06C74546  06C84547  06C94548  06CA4549  06CB4550  06CC4551  06CD4552  06CE4553  06CF4554  06D04555  06D14556  06D24557  06D34558  06D44559  06D54560  06D64561  06D74562  06D84563  06D94564  06DA4565  06DB4566  06DC4567  06DD4568  06DE4569  06DF4570  06E04571  06E14572  06E24573  06E34574  06E44575  06E54576  06E64577  06E74578  06E84579  06E94580  06EA4581  06EB4582  06EC4583  06ED4584  06EE4585  06EF4586  06F04587  06F14588  06F24589  06F34590  06F44591  06F54592  06F64593  06F74594  06F84595  06F94596  06FA4597  06FB4598  06FC4599  06FD4600  06FE4601  06FF4602  07004603  07014604  07024605  07034606  07044607  07054608  07064609  07074610  07084611  07094612  070A4613  070B4614  070C4615  070D4616  070E4617  070F4618  07104619  07114620  07124621  07134622  07144623  07154624  07164625  07174626  07184627  07194628  071A4629  071B4630  071C4631  071D4632  071E4633  071F4634  07204635  07214636  07224637  07234638  07244639  07254640  07264641  07274642  07284643  07294644  072A4645  072B4646  072C4647  072D4648  072E4649  072F4650  07304651  07314652  07324653  07334654  07344655  07354656  07364657  07374658  07384659  07394660  073A4661  073B4662  073C4663  073D4664  073E4665  073F4666  07404667  07414668  07424669  07434670  07444671  07454672  07464673  07474674  07484675  07494676  074A4677  074B4678  074C4679  074D4680  074E4681  074F4682  07504683  07514684  07524685  07534686  07544687  07554688  07564689  07574690  07584691  07594692  075A4693  075B4694  075C4695  075D4696  075E4697  075F4698  07604699  07614700  07624701  07634702  07644703  07654704  07664705  07674706  07684707  07694708  076A4709  076B4710  076C4711  076D4712  076E4713  076F4714  07704715  07714716  07724717  07734718  07744719  07754720  07764721  07774722  07784723  07794724  077A4725  077B4726  077C4727  077D4728  077E4729  077F4730  07804731  07814732  07824733  07834734  07844735  07854736  07864737  07874738  07884739  07894740  078A4741  078B4742  078C4743  078D4744  078E4745  078F4746  07904747  07914748  07924749  07934750  07944751  07954752  07964753  07974754  07984755  07994756  079A4757  079B4758  079C4759  079D4760  079E4761  079F4762  07A04763  07A14764  07A24765  07A34766  07A44767  07A54768  07A64769  07A74770  07A84771  07A94772  07AA4773  07AB4774  07AC4775  07AD4776  07AE4777  07AF4778  07B04779  07B14780  07B24781  07B34782  07B44783  07B54784  07B64785  07B74786  07B84787  07B94788  07BA4789  07BB4790  07BC4791  07BD4792  07BE4793  07BF4794  07C04795  07C14796  07C24797  07C34798  07C44799  07C54800  07C64801  07C74802  07C84803  07C94804  07CA4805  07CB4806  07CC4807  07CD4808  07CE4809  07CF4810  07D04811  07D14812  07D24813  07D34814  07D44815  07D54816  07D64817  07D74818  07D84819  07D94820  07DA4821  07DB4822  07DC4823  07DD4824  07DE4825  07DF4826  07E04827  07E14828  07E24829  07E34830  07E44831  07E54832  07E64833  07E74834  07E84835  07E94836  07EA4837  07EB4838  07EC4839  07ED4840  07EE4841  07EF4842  07F04843  07F14844  07F24845  07F34846  07F44847  07F54848  07F64849  07F74850  07F84851  07F94852  07FA4853  07FB4854  07FC4855  07FD4856  07FE4857  07FF4858  08004859  08014860  08024861  08034862  08044863  08054864  08064865  08074866  08084867  08094868  080A4869  080B4870  080C4871  080D4872  080E4873  080F4874  08104875  08114876  08124877  08134878  08144879  08154880  08164881  08174882  08184883  08194884  081A4885  081B4886  081C4887  081D4888  081E4889  081F4890  08204891  08214892  08224893  08234894  08244895  08254896  08264897  08274898  08284899  08294900  082A4901  082B4902  082C4903  082D4904  082E4905  082F4906  08304907  08314908  08324909  08334910  08344911  08354912  08364913  08374914  08384915  08394916  083A4917  083B4918  083C4919  083D4920  083E4921  083F4922  08404923  08414924  08424925  08434926  08444927  08454928  08464929  08474930  08484931  08494932  084A4933  084B4934  084C4935  084D4936  084E4937  084F4938  08504939  08514940  08524941  08534942  08544943  08554944  08564945  08574946  08584947  08594948  085A4949  085B4950  085C4951  085D4952  085E4953  085F4954  08604955  08614956  08624957  08634958  08644959  08654960  08664961  08674962  08684963  08694964  086A4965  086B4966  086C4967  086D4968  086E4969  086F4970  08704971  08714972  08724973  08734974  08744975  08754976  08764977  08774978  08784979  08794980  087A4981  087B4982  087C4983  087D4984  087E4985  087F4986  08804987  08814988  08824989  08834990  08844991  08854992  08864993  08874994  08884995  08894996  088A4997  088B4998  088C4999  088D5000  088E5001  088F5002  08905003  08915004  08925005  08935006  08945007  08955008  08965009  08975010  08985011  08995012  089A5013  089B5014  089C5015  089D5016  089E5017  089F5018  08A05019  08A15020  08A25021  08A35022  08A45023  08A55024  08A65025  08A75026  08A85027  08A95028  08AA5029  08AB5030  08AC5031  08AD5032  08AE5033  08AF5034  08B05035  08B15036  08B25037  08B35038  08B45039  08B55040  08B65041  08B75042  08B85043  08B95044  08BA5045  08BB5046  08BC5047  08BD5048  08BE5049  08BF5050  08C05051  08C15052  08C25053  08C35054  08C45055  08C55056  08C65057  08C75058  08C85059  08C95060  08CA5061  08CB5062  08CC5063  08CD5064  08CE5065  08CF5066  08D05067  08D15068  08D25069  08D35070  08D45071  08D55072  08D65073  08D75074  08D85075  08D95076  08DA5077  08DB5078  08DC5079  08DD5080  08DE5081  08DF5082  08E05083  08E15084  08E25085  08E35086  08E45087  08E55088  08E65089  08E75090  08E85091  08E95092  08EA5093  08EB5094  08EC5095  08ED5096  08EE5097  08EF5098  08F05099  08F15100  08F25101  08F35102  08F45103  08F55104  08F65105  08F75106  08F85107  08F95108  08FA5109  08FB5110  08FC5111  08FD5112  08FE5113  08FF5114  09005115  09015116  09025117  09035118  09045119  09055120  09065121  09075122  09085123  09095124  090A5125  090B5126  090C5127  090D5128  090E5129  090F5130  09105131  09115132  09125133  09135134  09145135  09155136  09165137  09175138  09185139  09195140  091A5141  091B5142  091C5143  091D5144  091E5145  091F5146  09205147  09215148  09225149  09235150  09245151  09255152  09265153  09275154  09285155  09295156  092A5157  092B5158  092C5159  092D5160  092E5161  092F5162  09305163  09315164  09325165  09335166  09345167  09355168  09365169  09375170  09385171  09395172  093A5173  093B5174  093C5175  093D5176  093E5177  093F5178  09405179  09415180  09425181  09435182  09445183  09455184  09465185  09475186  09485187  09495188  094A5189  094B5190  094C5191  094D5192  094E5193  094F5194  09505195  09515196  09525197  09535198  09545199  09555200  09565201  09575202  09585203  09595204  095A5205  095B5206  095C5207  095D5208  095E5209  095F5210  09605211  09615212  09625213  09635214  09645215  09655216  09665217  09675218  09685219  09695220  096A5221  096B5222  096C5223  096D5224  096E5225  096F5226  09705227  09715228  09725229  09735230  09745231  09755232  09765233  09775234  09785235  09795236  097A5237  097B5238  097C5239  097D5240  097E5241  097F5242  09805243  09815244  09825245  09835246  09845247  09855248  09865249  09875250  09885251  09895252  098A5253  098B5254  098C5255  098D5256  098E5257  098F5258  09905259  09915260  09925261  09935262  09945263  09955264  09965265  09975266  09985267  09995268  099A5269  099B5270  099C5271  099D5272  099E5273  099F5274  09A05275  09A15276  09A25277  09A35278  09A45279  09A55280  09A65281  09A75282  09A85283  09A95284  09AA5285  09AB5286  09AC5287  09AD5288  09AE5289  09AF5290  09B05291  09B15292  09B25293  09B35294  09B45295  09B55296  09B65297  09B75298  09B85299  09B95300  09BA5301  09BB5302  09BC5303  09BD5304  09BE5305  09BF5306  09C05307  09C15308  09C25309  09C35310  09C45311  09C55312  09C65313  09C75314  09C85315  09C95316  09CA5317  09CB5318  09CC5319  09CD5320  09CE5321  09CF5322  09D05323  09D15324  09D25325  09D35326  09D45327  09D55328  09D65329  09D75330  09D85331  09D95332  09DA5333  09DB5334  09DC5335  09DD5336  09DE5337  09DF5338  09E05339  09E15340  09E25341  09E35342  09E45343  09E55344  09E65345  09E75346  09E85347  09E95348  09EA5349  09EB5350  09EC5351  09ED5352  09EE5353  09EF5354  09F05355  09F15356  09F25357  09F35358  09F45359  09F55360  09F65361  09F75362  09F85363  09F95364  09FA5365  09FB5366  09FC5367  09FD5368  09FE5369  09FF5370  0A005371  0A015372  0A025373  0A035374  0A045375  0A055376  0A065377  0A075378  0A085379  0A095380  0A0A5381  0A0B5382  0A0C5383  0A0D5384  0A0E5385  0A0F5386  0A105387  0A115388  0A125389  0A135390  0A145391  0A155392  0A165393  0A175394  0A185395  0A195396  0A1A5397  0A1B5398  0A1C5399  0A1D5400  0A1E5401  0A1F5402  0A205403  0A215404  0A225405  0A235406  0A245407  0A255408  0A265409  0A275410  0A285411  0A295412  0A2A5413  0A2B5414  0A2C5415  0A2D5416  0A2E5417  0A2F5418  0A305419  0A315420  0A325421  0A335422  0A345423  0A355424  0A365425  0A375426  0A385427  0A395428  0A3A5429  0A3B5430  0A3C5431  0A3D5432  0A3E5433  0A3F5434  0A405435  0A415436  0A425437  0A435438  0A445439  0A455440  0A465441  0A475442  0A485443  0A495444  0A4A5445  0A4B5446  0A4C5447  0A4D5448  0A4E5449  0A4F5450  0A505451  0A515452  0A525453  0A535454  0A545455  0A555456  0A565457  0A575458  0A585459  0A595460  0A5A5461  0A5B5462  0A5C5463  0A5D5464  0A5E5465  0A5F5466  0A605467  0A615468  0A625469  0A635470  0A645471  0A655472  0A665473  0A675474  0A685475  0A695476  0A6A5477  0A6B5478  0A6C5479  0A6D5480  0A6E5481  0A6F5482  0A705483  0A715484  0A725485  0A735486  0A745487  0A755488  0A765489  0A775490  0A785491  0A795492  0A7A5493  0A7B5494  0A7C5495  0A7D5496  0A7E5497  0A7F5498  0A805499  0A815500  0A825501  0A835502  0A845503  0A855504  0A865505  0A875506  0A885507  0A895508  0A8A5509  0A8B5510  0A8C5511  0A8D5512  0A8E5513  0A8F5514  0A905515  0A915516  0A925517  0A935518  0A945519  0A955520  0A965521  0A975522  0A985523  0A995524  0A9A5525  0A9B5526  0A9C5527  0A9D5528  0A9E5529  0A9F5530  0AA05531  0AA15532  0AA25533  0AA35534  0AA45535  0AA55536  0AA65537  0AA75538  0AA85539  0AA95540  0AAA5541  0AAB5542  0AAC5543  0AAD5544  0AAE5545  0AAF5546  0AB05547  0AB15548  0AB25549  0AB35550  0AB45551  0AB55552  0AB65553  0AB75554  0AB85555  0AB95556  0ABA5557  0ABB5558  0ABC5559  0ABD5560  0ABE5561  0ABF5562  0AC05563  0AC15564  0AC25565  0AC35566  0AC45567  0AC55568  0AC65569  0AC75570  0AC85571  0AC95572  0ACA5573  0ACB5574  0ACC5575  0ACD5576  0ACE5577  0ACF5578  0AD05579  0AD15580  0AD25581  0AD35582  0AD45583  0AD55584  0AD65585  0AD75586  0AD85587  0AD95588  0ADA5589  0ADB5590  0ADC5591  0ADD5592  0ADE5593  0ADF5594  0AE05595  0AE15596  0AE25597  0AE35598  0AE45599  0AE55600  0AE65601  0AE75602  0AE85603  0AE95604  0AEA5605  0AEB5606  0AEC5607  0AED5608  0AEE5609  0AEF5610  0AF05611  0AF15612  0AF25613  0AF35614  0AF45615  0AF55616  0AF65617  0AF75618  0AF85619  0AF95620  0AFA5621  0AFB5622  0AFC5623  0AFD5624  0AFE5625  0AFF5626  0B005627  0B015628  0B025629  0B035630  0B045631  0B055632  0B065633  0B075634  0B085635  0B095636  0B0A5637  0B0B5638  0B0C5639  0B0D5640  0B0E5641  0B0F5642  0B105643  0B115644  0B125645  0B135646  0B145647  0B155648  0B165649  0B175650  0B185651  0B195652  0B1A5653  0B1B5654  0B1C5655  0B1D5656  0B1E5657  0B1F5658  0B205659  0B215660  0B225661  0B235662  0B245663  0B255664  0B265665  0B275666  0B285667  0B295668  0B2A5669  0B2B5670  0B2C5671  0B2D5672  0B2E5673  0B2F5674  0B305675  0B315676  0B325677  0B335678  0B345679  0B355680  0B365681  0B375682  0B385683  0B395684  0B3A5685  0B3B5686  0B3C5687  0B3D5688  0B3E5689  0B3F5690  0B405691  0B415692  0B425693  0B435694  0B445695  0B455696  0B465697  0B475698  0B485699  0B495700  0B4A5701  0B4B5702  0B4C5703  0B4D5704  0B4E5705  0B4F5706  0B505707  0B515708  0B525709  0B535710  0B545711  0B555712  0B565713  0B575714  0B585715  0B595716  0B5A5717  0B5B5718  0B5C5719  0B5D5720  0B5E5721  0B5F5722  0B605723  0B615724  0B625725  0B635726  0B645727  0B655728  0B665729  0B675730  0B685731  0B695732  0B6A5733  0B6B5734  0B6C5735  0B6D5736  0B6E5737  0B6F5738  0B705739  0B715740  0B725741  0B735742  0B745743  0B755744  0B765745  0B775746  0B785747  0B795748  0B7A5749  0B7B5750  0B7C5751  0B7D5752  0B7E5753  0B7F5754  0B805755  0B815756  0B825757  0B835758  0B845759  0B855760  0B865761  0B875762  0B885763  0B895764  0B8A5765  0B8B5766  0B8C5767  0B8D5768  0B8E5769  0B8F5770  0B905771  0B915772  0B925773  0B935774  0B945775  0B955776  0B965777  0B975778  0B985779  0B995780  0B9A5781  0B9B5782  0B9C5783  0B9D5784  0B9E5785  0B9F5786  0BA05787  0BA15788  0BA25789  0BA35790  0BA45791  0BA55792  0BA65793  0BA75794  0BA85795  0BA95796  0BAA5797  0BAB5798  0BAC5799  0BAD5800  0BAE5801  0BAF5802  0BB05803  0BB15804  0BB25805  0BB35806  0BB45807  0BB55808  0BB65809  0BB75810  0BB85811  0BB95812  0BBA5813  0BBB5814  0BBC5815  0BBD5816  0BBE5817  0BBF5818  0BC05819  0BC15820  0BC25821  0BC35822  0BC45823  0BC55824  0BC65825  0BC75826  0BC85827  0BC95828  0BCA5829  0BCB5830  0BCC5831  0BCD5832  0BCE5833  0BCF5834  0BD05835  0BD15836  0BD25837  0BD35838  0BD45839  0BD55840  0BD65841  0BD75842  0BD85843  0BD95844  0BDA5845  0BDB5846  0BDC5847  0BDD5848  0BDE5849  0BDF5850  0BE05851  0BE15852  0BE25853  0BE35854  0BE45855  0BE55856  0BE65857  0BE75858  0BE85859  0BE95860  0BEA5861  0BEB5862  0BEC5863  0BED5864  0BEE5865  0BEF5866  0BF05867  0BF15868  0BF25869  0BF35870  0BF45871  0BF55872  0BF65873  0BF75874  0BF85875  0BF95876  0BFA5877  0BFB5878  0BFC5879  0BFD5880  0BFE5881  0BFF5882  0C005883  0C015884  0C025885  0C035886  0C045887  0C055888  0C065889  0C075890  0C085891  0C095892  0C0A5893  0C0Bfile D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\defines.inc

5894  0006             #inherit "defines.inc"
5895  0006             #inherit "defines.inc"
5896  0001   
5897  0004              */
5898  0005             #CONST
5899  0028             #END
5900  0029   
5901  0032              */
5902  0033             #CONST
5903  0057             #END
5904  0058   
5905  0061              */
Notice: empty data block (line 64 file:defines.inc)
5906  0064             #END
5907  0065   
file D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\display.fnc

5908  0007             #inherit "display.fnc"
5909  0007             #inherit "display.fnc"
5910  0003              */
5911  0004             func RPM_Meter( var val )
5912  0005   
5913  0006                 gfx_PenSize( SOLID );
5914  0007   
5915  0008                 var i;
5916  0009                 var counter:=0;                                             /* match counter */
5917  0010                 var targetX1, targetY1;                                     /* Orbit targets */
5918  0011                 var targetX2, targetY2;
5919  0012                 gfx_OrbitInit( &targetX1, &targetY1 );
5920  0013                 gfx_MoveTo( 90, 90);
5921  0014   
5922  0015                 for( i:=90; i<=270; i:= i + 2 )                             /* Snail */
5923  0016   
5924  0017                     gfx_Orbit( i, 90 );
5925  0018                     targetX2 := targetX1;
5926  0019                     targetY2 := targetY1;
5927  0020                     gfx_Orbit( i, 135 - ( i>>1 ) );                         /* Coil */
5928  0021   
5929  0022                     if( counter < val )                                     /* Printing Ranges */
5930  0023   
5931  0024                         if( counter < RPM_RANGE1 )
5932  0025                             gfx_Line( targetX2, targetY2, targetX1, targetY1, RPM_COL_RANGE1 );
5933  0026                         else if ( ( counter >= RPM_RANGE1 ) && ( counter <= RPM_RANGE2 ) )
5934  0027                             gfx_Line( targetX2, targetY2, targetX1, targetY1, RPM_COL_RANGE2 );
5935  0028                         else
5936  0029                             gfx_Line( targetX2, targetY2, targetX1, targetY1, RPM_COL_RANGE3 );
5937  0030                         endif
5938  0031   
5939  0032                     else
5940  0033                         gfx_Line( targetX2, targetY2, targetX1, targetY1, BLACK );
5941  0034                     endif
5942  0035   
5943  0036                     counter += 58;
5944  0037                 next
5945  0038   
5946  0039                 for( i:=90; i<=320; i := i+4 )                              /* Straight Lane */
5947  0040   
5948  0041                     if( counter < val )
5949  0042   
5950  0043                         if ( counter < RPM_RANGE1 )
5951  0044                             gfx_Vline( i, 0, 90, RPM_COL_RANGE1 );
5952  0045                         else if ( ( counter >= RPM_RANGE1 ) && ( counter <= RPM_RANGE2 ) )
5953  0046                             gfx_Vline( i, 0, 90, RPM_COL_RANGE2 );
5954  0047                         else
5955  0048                              gfx_Vline( i, 0, 90, RPM_COL_RANGE3 );
5956  0049                         endif
5957  0050                     else
5958  0051                         gfx_Vline( i, 0, 90, BLACK );
5959  0052                     endif
5960  0053   
5961  0054                     counter += 116;                                           /* Lines */
5962  0055                 next
5963  0056   
5964  0057                 gfx_MoveTo( RPM_X, RPM_Y );                                 /* RPM Value */
5965  0058                 txt_FontID(FONT4);
5966  0059                 txt_Bold(1);
5967  0060                 txt_Width(3);
5968  0061                 txt_Height(3);
5969  0062   
5970  0063                 var private gear_pos :=0;
5971  0064   
5972  0065                 if( gear_pos != GearPosition )                              /* Flash When Gear Changes */
5973  0066                     txt_FGcolour( BLUE );
5974  0067                     gear_pos := GearPosition;
5975  0068                 else
5976  0069                     txt_FGcolour( YELLOW );
5977  0070                 endif
5978  0071   
5979  0072                 print(val);                                                 /* Numeric Value */
5980  0073                 print(" ");
5981  0074   
5982  0075                 gfx_MoveTo( RPM_X + 185, RPM_Y + 25 );                      /* RPM */
5983  0076                 txt_FontID(FONT2);
5984  0077                 txt_FGcolour( WHITE );
5985  0078                 txt_Bold(0);
5986  0079                 txt_Width(1);
5987  0080                 txt_Height(2);
5988  0081                 print("RPM");
5989  0082             endfunc
5990  0083   
5991  0086              */
5992  0087             func Speed_Disp( var kmph )
5993  0088   
5994  0089                 gfx_MoveTo( SPEED_X, SPEED_Y );                             /* RPM */
5995  0090                 txt_FontID(FONT4);
5996  0091                 txt_FGcolour( CYAN );
5997  0092                 txt_Bold(1);
5998  0093                 txt_Width(2);
5999  0094                 txt_Height(2);
6000  0095                 print(kmph);
6001  0096                 print(" ");
6002  0097   
6003  0098                 gfx_MoveTo( SPEED_X + 90, SPEED_Y + 15 );                   /* RPM */
6004  0099                 txt_FontID(FONT2);
6005  0100                 txt_FGcolour( WHITE );
6006  0101                 txt_Bold(0);
6007  0102                 txt_Width(1);
6008  0103                 txt_Height(2);
6009  0104                 print("KMPH");
6010  0105             endfunc
6011  0106   
6012  0109              */
6013  0110              func Gear_Disp( var val )
6014  0111   
6015  0112                 gfx_MoveTo( NEUTRAL_X, NEUTRAL_Y );
6016  0113                 txt_FontID(FONT4);
6017  0114                 txt_Bold(1);
6018  0115                 txt_Width(2);
6019  0116                 txt_Height(2);
6020  0117   
6021  0118                 if( ( val >= 0 ) && ( val <= 5 ) )                          /* Change colour */
6022  0119   
6023  0120                     txt_FGcolour( WHITE );
6024  0121                     if( val  == 0 )
6025  0122                         print("N");
6026  0123                     else
6027  0124                         print(val);
6028  0125                     endif
6029  0126                 else
6030  0127                     txt_FGcolour( BLACK );
6031  0128                     print("N");
6032  0129                 endif
6033  0130   
6034  0131              endfunc
6035  0132   
6036  0135              */
6037  0136             func Pneumatic_Disp()
6038  0137   
6039  0138                 txt_FontID(FONT1);
6040  0139                 txt_FGcolour( RED );
6041  0140                 txt_Bold(1);
6042  0141                 txt_Width(2);
6043  0142                 txt_Height(2);
6044  0143   
6045  0144                 if( ( PneumState == PNEUM_OFF ) && ( PneumFlashState == PNEUM_FLASH_OFF ) && ( sys_GetTimer(TIMER3) == 0 ) )
6046  0145                     gfx_MoveTo( 190, 215 );
6047  0146                     print ( "PNEUM OFF" );
6048  0147                     PneumFlashState := PNEUM_FLASH_ON;
6049  0148                     sys_SetTimer(TIMER3, 500);
6050  0149                 endif
6051  0150   
6052  0151                 if( ( PneumState == PNEUM_OFF ) && ( PneumFlashState == PNEUM_FLASH_ON ) && ( sys_GetTimer(TIMER3) == 0 ) )
6053  0152                     gfx_MoveTo( 190, 215 );
6054  0153                     print ( "         " );
6055  0154                     PneumFlashState := PNEUM_FLASH_OFF;
6056  0155                     sys_SetTimer(TIMER3, 500);
6057  0156                 endif
6058  0157   
6059  0158                 if( PneumState == PNEUM_ON )
6060  0159                      gfx_MoveTo( 190, 215 );
6061  0160                      txt_FGcolour( LIME );
6062  0161                      print ( "PNEUM ON " );
6063  0162                 endif
6064  0163   
6065  0164             endfunc
6066  0165   
6067  0168              */
6068  0169              func Warnings_Disp()
6069  0170   
6070  0171                  /* OIL WARNING */
6071  0172                 txt_FontID(FONT4);
6072  0173                 txt_FGcolour( SKYBLUE );
6073  0174                 txt_Bold(1);
6074  0175                 txt_Width(2);
6075  0176                 txt_Height(2);
6076  0177   
6077  0178                 if( ( OilWarningState == OIL_WARNING_ON ) && ( OilFlashState == OIL_WARNING_FLASH_OFF ) && ( sys_GetTimer(TIMER0) == 0 ) )
6078  0179                     gfx_MoveTo( 190, 150 );
6079  0180                     print ( "OIL" );
6080  0181                     OilFlashState := OIL_WARNING_FLASH_ON;
6081  0182                     sys_SetTimer(TIMER0, 100);
6082  0183                 endif
6083  0184   
6084  0185                 if( ( OilWarningState == OIL_WARNING_ON ) && ( OilFlashState == OIL_WARNING_FLASH_ON ) && ( sys_GetTimer(TIMER0) == 0 ) )
6085  0186                     gfx_MoveTo( 190, 150 );
6086  0187                     print ( "   " );
6087  0188                     OilFlashState := OIL_WARNING_FLASH_OFF;
6088  0189                     sys_SetTimer(TIMER0, 100);
6089  0190                 endif
6090  0191   
6091  0192                 if( OilWarningState == OIL_WARNING_OFF )
6092  0193                      gfx_MoveTo( 190, 150 );
6093  0194                      print ( "   " );
6094  0195                 endif
6095  0196   
6096  0197                 /* ENGINE TEMPERATURE WARNING */
6097  0198                 txt_FontID(FONT4);
6098  0199                 txt_FGcolour( RED );
6099  0200                 txt_Bold(1);
6100  0201                 txt_Width(2);
6101  0202                 txt_Height(2);
6102  0203   
6103  0204                 if( ( TempWarningState == TEMP_WARNING_ON ) && ( TempFlashState == TEMP_WARNING_FLASH_OFF ) && ( sys_GetTimer(TIMER1) == 0 ) )
6104  0205                     gfx_MoveTo( 100, 150 );
6105  0206                     print ( "HOT" );
6106  0207                     TempFlashState := TEMP_WARNING_FLASH_ON;
6107  0208                     sys_SetTimer(TIMER1, 100);
6108  0209                 endif
6109  0210   
6110  0211                 if( ( TempWarningState == TEMP_WARNING_ON ) && ( TempFlashState == TEMP_WARNING_FLASH_ON ) && ( sys_GetTimer(TIMER1) == 0 ) )
6111  0212                     gfx_MoveTo( 100, 150 );
6112  0213                     print ( "   " );
6113  0214                     TempFlashState := TEMP_WARNING_FLASH_OFF;
6114  0215                     sys_SetTimer(TIMER1, 100);
6115  0216                 endif
6116  0217   
6117  0218                 if( TempWarningState == TEMP_WARNING_OFF )
6118  0219                      gfx_MoveTo( 100, 150 );
6119  0220                      print ( "   " );
6120  0221                 endif
6121  0222              endfunc
6122  0223   
6123  0226              */
6124  0227             func NoConnection_Disp()
6125  0228   
6126  0229                 txt_FontID(FONT4);
6127  0230                 txt_FGcolour( RED );
6128  0231                 txt_Bold(1);
6129  0232                 txt_Width(2);
6130  0233                 txt_Height(2);
6131  0234   
6132  0235                 if( ( ConnectionFlashState == CON_FLASH_ON ) && ( sys_GetTimer(TIMER5) == 0 ) )
6133  0236                     gfx_Cls();
6134  0237                     ConnectionFlashState := CON_FLASH_OFF;
6135  0238                     sys_SetTimer(TIMER5, 500);
6136  0239                 endif
6137  0240   
6138  0241                 if( ( ConnectionFlashState == CON_FLASH_OFF ) && ( sys_GetTimer(TIMER5) == 0 ) )
6139  0242                     gfx_MoveTo( 15, 110 );
6140  0243                     print ( "DISCONNECTED" );
6141  0244                     ConnectionFlashState := CON_FLASH_ON;
6142  0245                     sys_SetTimer(TIMER5, 500);
6143  0246                 endif
6144  0247             endfunc
6145  0248   
6146  0251              */
6147  0252              func FM_LOGO()
6148  0253   
6149  0254                 txt_Set(FONT_SIZE, FONT1);
6150  0255                 var count := 0;
6151  0256                 putstr("Mounting");
6152  0257   
6153  0258                 if (!(D:=file_Mount()))                                         /* MOUNT DRIVE */
6154  0259                     while( !( D:=file_Mount() ) && ( count<=5) )
6155  0260                         count++;
6156  0261                     wend
6157  0262                 endif
6158  0263   
6159  0264                 gfx_Cls();
6160  0265                 if ( (D:=file_Mount()) )                                        /* Check Mounted */
6161  0266                     putstr("Mounted");
6162  0267                 else
6163  0268                     putstr("Mounting FAILED");
6164  0269                 endif
6165  0270   
6166  0271                 pause(500);
6167  0272                 gfx_Cls();                                                      /* Clear Screen */
6168  0273   
6169  0274                 Ihndl := file_LoadImageControl("fm.dat", "fm.gci",1);           /* use fast mode 1 for this type of work */
6170  0275                 img_Show(Ihndl, ALL);                                           /* Show Logo */
6171  0276   
6172  0277                 var i;
6173  0278                 for( i:= 0; i<=320; i++ )                                       /* Fill with Bars */
6174  0279   
6175  0280                     if( i%2 == 0 )
6176  0281                         gfx_Vline( i, 180, 220, RED );
6177  0282                         gfx_Vline( 320 - i, 20, 60, RED );
6178  0283                     endif
6179  0284                 next
6180  0285   
6181  0286                 for( i:= 0; i<=320; i++ )                                       /* Slide out Bars */
6182  0287   
6183  0288                     if( i%2 == 0 )
6184  0289                         gfx_Vline( i, 180, 220, BLACK );
6185  0290                         gfx_Vline( 320 - i, 20, 60, BLACK );
6186  0291                     endif
6187  0292                     pause(7);
6188  0293                 next
6189  0294   
6190  0295             endfunc
6191  0296   
file D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\connect.fnc

6192  0008             #inherit "connect.fnc"
6193  0008             #inherit "connect.fnc"
6194  0003              */
6195  0004              func Serial_Init()
6196  0005   
6197  0006                 var stat;
6198  0007   
6199  0008                 stat := com_SetBaud( COM1, BAUD_RATE );            /* Open Port */
6200  0009   
6201  0010                 if (stat)
6202  0011                     print("Com1 set to BAUD");
6203  0012                     gfx_Cls();
6204  0013                 endif
6205  0014   
6206  0015                 com1_Init( Buffer, BUFFER_SIZE, SERIAL_QFY );           /* Initialize Buffer */
6207  0016   
6208  0017              endfunc
6209  0018   
6210  0021              */
6211  0022             func Connection()
6212  0023   
6213  0024                 if( com1_Sync() )                                       /* Check if connected */
6214  0025                     sys_SetTimer(TIMER4, 1000);
6215  0026                     ConnectionState := CONNECTED;
6216  0027                 endif
6217  0028   
6218  0029                 if( sys_GetTimer(TIMER4)  == 0 )                        /* Disconnect after 1 sec */
6219  0030                     ConnectionState := DISCONNECTED;
6220  0031                 endif
6221  0032   
6222  0033             endfunc
6223  0034   
6224  0037              */
6225  0038              func Read_Data()
6226  0039   
6227  0040                 var i, ch;
6228  0041   
6229  0042                 if( com1_Full() )                                       /* If Buffer Full */
6230  0043   
6231  0044                     for( i:=0; i<BUFFER_SIZE; i++ )
6232  0045                         ReadBuffer[i] := serin1();                      /* Read line by line */
6233  0046                     next
6234  0047   
6235  0048                     /* Read RPM */
6236  0049                     Rpm := ( ( ReadBuffer[0]<<8 ) | ReadBuffer[1] );
6237  0050   
6238  0051                     /* KMPH */
6239  0052                     Kmph := ReadBuffer[2];
6240  0053   
6241  0054                     /* Gear Position */
6242  0055                     GearPosition := ReadBuffer[3];
6243  0056   
6244  0057                     /* Pneumatic Status */
6245  0058                     if( ReadBuffer[4] == 255 )
6246  0059                         PneumState := PNEUM_ON;
6247  0060                     else if ( ReadBuffer[4] == 0 )
6248  0061                         PneumState := PNEUM_OFF;
6249  0062                     endif
6250  0063   
6251  0064                     /* TEMP (HOT) Warning */
6252  0065                     if( ReadBuffer[5] == 255 )
6253  0066                         TempWarningState := TEMP_WARNING_ON;
6254  0067                     else if ( ReadBuffer[5] == 0 )
6255  0068                         TempWarningState := TEMP_WARNING_OFF;
6256  0069                     endif
6257  0070   
6258  0071                     /* OIL Warning */
6259  0072                     if( ReadBuffer[6] == 255 )
6260  0073                         OilWarningState := OIL_WARNING_ON;
6261  0074                     else if ( ReadBuffer[6] == 0 )
6262  0075                         OilWarningState := OIL_WARNING_OFF;
6263  0076                     endif
6264  0077   
6265  0078                     com1_Init( Buffer, BUFFER_SIZE, SERIAL_QFY );        /* ReInitialize Buffer */
6266  0079                 endif
6267  0080              endfunc
6268  0081   
6269  0082   
6270  0009   
6271  0015             */
6272  0016   
6273  0017             #STACK 500                                      /* Initialize stack memory */
6274  0018   
6275  0021              */
6276  0022             var D;                                          /* Disk */
6277  0023   
6278  0024             var Buffer[BUFFER_SIZE];                        /* Serial Rx Buffer */
6279  0025             var ReadBuffer[BUFFER_SIZE];                    /* Read copy Buffer */
6280  0026   
6281  0027             var Rpm;                                        /* RPM variable */
6282  0028             var Kmph;                                       /* KMPH variable */
6283  0029             var GearPosition;                               /* Gear Position */
6284  0030   
6285  0031             var *Ihndl;                                     /* Handle for image control */
6286  0032   
6287  0033             var ConnectionState;                            /* Connection State */
6288  0034             var ConnectionFlashState;
6289  0035             var OilWarningState;                            /* Oil Warning */
6290  0036             var OilFlashState;
6291  0037             var TempWarningState;                           /* Temperature Warning */
6292  0038             var TempFlashState;
6293  0039             var PneumState;                                 /* PneumState */
6294  0040             var PneumFlashState;
6295  0041   
6296  0044              */
6297  0045             func main()
6298  0046   
6299  0047                 ConnectionState := DISCONNECTED;            /* Initialize variables */
6300  0048                 ConnectionFlashState := CON_FLASH_OFF;
6301  0049                 OilWarningState := OIL_WARNING_OFF;
6302  0050                 OilFlashState := OIL_WARNING_FLASH_OFF;
6303  0051                 TempWarningState := TEMP_WARNING_OFF;
6304  0052                 TempFlashState := TEMP_WARNING_FLASH_OFF;
6305  0053                 PneumState := PNEUM_OFF;
6306  0054                 PneumFlashState := PNEUM_FLASH_OFF;
6307  0055                 Rpm := 0;
6308  0056                 Kmph := 0;
6309  0057                 GearPosition := 0;
6310  0058   
6311  0059                 gfx_ScreenMode( LANDSCAPE );                /* Change to Landscape Mode */
6312  0060                 gfx_Cls();                                  /* Clear the Screen */
6313  0061   
6314  0062                 FM_LOGO();                                  /* Display starting logo */
6315  0063                 gfx_Cls();
6316  0064   
6317  0065                 Serial_Init();                              /* Initialize Serial Port */
6318  0066   
6319  0067                 /* LOOP FOREVER */
6320  0068                 while(1)
6321  0069   
6322  0070                     Connection();                           /* Check Connection */
6323  0071   
6324  0072                     if( ( ConnectionState == CONNECTED ) && ( ConnectionFlashState == CON_FLASH_OFF ) )
6325  0073   
6326  0074                         Read_Data();                        /* Read Data from Serial Port */
6327  0075                         RPM_Meter( Rpm );
6328  0076                         Speed_Disp( Kmph );
6329  0077                         Gear_Disp( GearPosition );
6330  0078                         Warnings_Disp();                     /* Show Warnings */
6331  0079                         Pneumatic_Disp();                    /* Show Pneumatic State */
6332  0080   
6333  0081                     else
6334  0082                         NoConnection_Disp();                /* Display Error in Connection */
6335  0083                     endif
6336  0084                 wend
6337  0085             endfunc
6338  0086   
6339  0087   
Notice: local var 'ch' in func 'Read_Data' is never used (line 40 file:connect.fnc)


Symbol Table:
name                 decimal    hex
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
ALL                                65535  0x0000ffff (const dword)  (usage 1)
BAUD_RATE                           3840  0x00000f00 (const dword)  (usage 1)
BLACK                                  0  0x00000000 (const dword)  (usage 5)
BLUE                                  31  0x0000001f (const dword)  (usage 1)
Buffer                                 4  0x00000004 (mem) word[7] (global)  (usage 2)
BUFFER_SIZE                            7  0x00000007 (const dword)  (usage 5)
COM1                               63496  0x0000f808 (const dword)  (usage 1)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (usage 1)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (usage 2)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (usage 1)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 1)
CON_FLASH_OFF                          3  0x00000003 (const ??? 0)  (usage 4)
CON_FLASH_ON                           2  0x00000002 (const ??? 0)  (usage 2)
CONNECTED                              0  0x00000000 (const ??? 0)  (usage 2)
Connection                          3452  0x00000d7c (User func) args[0] r=0  (usage 1)
ConnectionFlashState                  42  0x0000002a (mem) word (global)  (usage 6)
ConnectionState                       40  0x00000028 (mem) word (global)  (usage 4)
CYAN                                2047  0x000007ff (const dword)  (usage 1)
D                                      2  0x00000002 (mem) word (global)  (usage 3)
DISCONNECTED                           1  0x00000001 (const ??? 0)  (usage 2)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 1)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 3)
FM_LOGO                             3563  0x00000deb (User func) args[0] r=0  (usage 1)
FONT1                                  0  0x00000000 (const dword)  (usage 2)
FONT2                                  1  0x00000001 (const dword)  (usage 2)
FONT4                                  7  0x00000007FONT4                                  7  0x00000007 (mem) byte[3077] (member of D:\Dropbox\My Projects\CAN BUS & TELEMETRY\Display\CODE\CAR_LCD\CAR_3.4DG)  (usage 6)
FONT_SIZE                              2  0x00000002 (const dword)  (usage 1)
Gear_Disp                           4763  0x0000129b (User func) args[1] r=0  (usage 1)
gear_pos                          UNRESOLVED  (usage 2)
GearPosition                          36  0x00000024 (mem) word (global)  (usage 5)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 4)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 16)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (usage 2)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (usage 1)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (usage 1)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 1)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (usage 8)
Ihndl                                 38  0x00000026 (mem) word (global)  (usage 2)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 1)
Kmph                                  34  0x00000022 (mem) word (global)  (usage 3)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 1)
LIME                                2016  0x000007e0 (const dword)  (usage 2)
NEUTRAL_X                             60  0x0000003c (const dword)  (usage 1)
NEUTRAL_Y                            100  0x00000064 (const dword)  (usage 1)
NoConnection_Disp                   3911  0x00000f47 (User func) args[0] r=0  (usage 1)
OIL_WARNING_FLASH_OFF                  7  0x00000007 (const ??? 0)  (usage 3)
OIL_WARNING_FLASH_ON                   6  0x00000006 (const ??? 0)  (usage 2)
OIL_WARNING_OFF                        5  0x00000005 (const ??? 0)  (usage 3)
OIL_WARNING_ON                         4  0x00000004 (const ??? 0)  (usage 3)
OilFlashState                         46  0x0000002e (mem) word (global)  (usage 5)
OilWarningState                       44  0x0000002c (mem) word (global)  (usage 6)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 2)
PICASO                                 1  0x00000001 (const dword)  (usage 1)
PNEUM_FLASH_OFF                       15  0x0000000f (const ??? 0)  (usage 3)
PNEUM_FLASH_ON                        14  0x0000000e (const ??? 0)  (usage 2)
PNEUM_OFF                             13  0x0000000d (const ??? 0)  (usage 4)
PNEUM_ON                              12  0x0000000c (const ??? 0)  (usage 2)
Pneumatic_Disp                      4514  0x000011a2 (User func) args[0] r=0  (usage 1)
PneumFlashState                       54  0x00000036 (mem) word (global)  (usage 5)
PneumState                            52  0x00000034 (mem) word (global)  (usage 6)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 3)
Read_Data                           3272  0x00000cc8 (User func) args[0] r=0  (usage 1)
ReadBuffer                            18  0x00000012 (mem) word[7] (global)  (usage 11)
RED                                63488  0x0000f800 (const dword)  (usage 6)
Rpm                                   32  0x00000020 (mem) word (global)  (usage 3)
RPM_COL_RANGE1                      2016  0x000007e0 (const dword)  (usage 2)
RPM_COL_RANGE2                     65504  0x0000ffe0 (const dword)  (usage 2)
RPM_COL_RANGE3                     63488  0x0000f800 (const dword)  (usage 2)
RPM_Meter                           5043  0x000013b3 (User func) args[1] r=0  (usage 1)
RPM_Meter.gear_pos                     0  0x00000000 (mem) word (member of RPM_Meter)  (usage 2)
RPM_RANGE1                          2000  0x000007d0 (const dword)  (usage 4)
RPM_RANGE2                          4500  0x00001194 (const dword)  (usage 2)
RPM_X                                100  0x00000064 (const dword)  (usage 2)
RPM_Y                                100  0x00000064 (const dword)  (usage 2)
Serial_Init                         3497  0x00000da9 (User func) args[0] r=0  (usage 1)
SERIAL_QFY                            58  0x0000003a (const dword)  (usage 2)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (usage 1)
SKYBLUE                            34429  0x0000867d (const dword)  (usage 1)
SOLID                                  0  0x00000000 (const dword)  (usage 1)
Speed_Disp                          4893  0x0000131d (User func) args[1] r=0  (usage 1)
SPEED_X                               10  0x0000000a (const dword)  (usage 2)
SPEED_Y                              205  0x000000cd (const dword)  (usage 2)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (usage 9)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (usage 9)
TEMP_WARNING_FLASH_OFF                11  0x0000000b (const ??? 0)  (usage 3)
TEMP_WARNING_FLASH_ON                 10  0x0000000a (const ??? 0)  (usage 2)
TEMP_WARNING_OFF                       9  0x00000009 (const ??? 0)  (usage 3)
TEMP_WARNING_ON                        8  0x00000008 (const ??? 0)  (usage 3)
TempFlashState                        50  0x00000032 (mem) word (global)  (usage 5)
TempWarningState                      48  0x00000030 (mem) word (global)  (usage 6)
TIMER0                                 0  0x00000000 (const dword)  (usage 4)
TIMER1                                 1  0x00000001 (const dword)  (usage 4)
TIMER3                                 3  0x00000003 (const dword)  (usage 4)
TIMER4                                 4  0x00000004 (const dword)  (usage 2)
TIMER5                                 5  0x00000005 (const dword)  (usage 4)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (usage 9)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 12)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 9)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (usage 9)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (usage 1)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (usage 9)
Warnings_Disp                       4073  0x00000fe9 (User func) args[0] r=0  (usage 1)
WHITE                              65535  0x0000ffff (const dword)  (usage 3)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 2)
